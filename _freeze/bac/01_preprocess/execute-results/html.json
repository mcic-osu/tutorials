{
  "hash": "e2d59e8b635e0b8686aca194e24a972b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Read QC & preprocessing\"\npagetitle: \"Read QC & preprocessing\"\nauthor: Jelmer Poelstra\ndate: 2024-02-08\nexecute: \n  eval: false\nknitr:\n  opts_chunk:\n    out.width: \"85%\"\n    class-output: bash-out\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n<br>\n\n## Introduction {-}\n\nThe first series of steps our bacterial whole-genome analysis workflow concerns\nthe quality control (QC) & \"preprocessing\" of the reads.\n\nThe QC part will leave the data untouched,\nwhereas the preprocessing involved the removal of unwanted bits of sequence.\nAfter the preprocessing, we will still have FASTQ files, just with somewhat less content.\n\nWe will preprocess our reads with the following steps:\n\n1. QC with **FastQC**\n2. Summarizing FastQC results with **MultiQC**\n3. Removing adapters and low-quality bases from our reads with **TrimGalore**\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: exercise\n#### {{< fa user-edit >}} **Setting up**\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n**Start a new VS Code session with an open terminal:**\n\n1.  Log in to OSC's OnDemand portal at <https://ondemand.osc.edu>.\n\n2.  In the blue top bar, select `Interactive Apps` and then near the bottom of the dropdown menu, click `Code Server`.\n\n3.  In the form that appears on a new page:\n    -   Select OSC project `PAS2250`\n    -   The starting directory: `/fs/scratch/PAS2250/cabana/<user>`\n    -   `Number of hours`: `10`\n    -   Click `Launch`.\n\n4.  On the next page, once the top bar of the box has turned green and says `Runnning`, click `Connect to VS Code`.\n\n5.  Open a Terminal by clicking   {{< fa bars >}}   =\\> `Terminal` =\\> `New Terminal`.\n\n6.  In the terminal, move into your `bact/bact` dir:\n\n    ```bash\n    cd bact/bact # Full path: /fs/scratch/PAS2250/cabana/$USER/bact/bact\n    ```\n\n7.  Optional: open a file to save your commands.\n    In the Explorer (file browser) on the left, you should be able to find\n    the `workflow.sh` script you created yesterday.\n\n:::\n\n<br>\n\n## The FASTQ format\n\nFASTQ is a very common output format of high-throughput sequencing machines — at least from Illumina sequencing, you will almost always receive the sequences in this format. *Like most genomic data files, these are plain text files*, and each sequence that is read by the sequencer (i.e., each \"read\") forms **one FASTQ entry represented by four lines**. The lines contain, respectively:\n\n1.  A **header** that starts with `@` and e.g. uniquely identifies the read\n2.  The **sequence** itself\n3.  A **`+`** (plus sign)\n4.  One-character **quality scores** for each base in the sequence\n\n<figure><p align=\"center\">\n<img src=\"img/fastq_header.png\" width=\"85%\"/>\n\n<figcaption>One entry (read) in a FASTQ file covers 4 lines. <br>The header line is annotated, with some of the more useful components highlighted in red. <br>For viewing purposes, this read (at only 56 bp) is shorter than what is typical.</figcaption>\n\n</p></figure>\n\nThe \"Q\" in FASTQ stands for \"*quality*\", to contrast this format with FASTA, a more basic and generic format that does not include base quality scores. FASTQ files have the extension `.fastq` or `.fq`, but they are very commonly gzip-compressed, in which case their name ends in `.fastq.gz` or `.fq.gz`.\n\n::: {.callout-note collapse=\"true\"}\n#### FASTQ quality scores *(Click to expand)*\n\nThe quality scores we saw in the read above represent an **estimate of the error probability of the base call**. Specifically, they correspond to a numeric \"Phred\" quality score (`Q`), which is a function of the estimated probability that a base call is erroneous (`P`):\n\n> **Q = -10 \\* log10(P)**\n\nFor some specific probabilities and their rough qualitative interpretations for Illumina data:\n\n| Phred quality score | Error probability | Rough interpretation | ASCII character |\n|------------------|------------------|------------------|------------------|\n| **10**              | 1 in 10           | terrible             | `+`             |\n| **20**              | 1 in 100          | bad                  | `5`             |\n| **30**              | 1 in 1,000        | good                 | `?`             |\n| **40**              | 1 in 10,000       | excellent            | `?`             |\n\nThis numeric quality score is represented in FASTQ files *not by the number itself*, but by a corresponding \"ASCII character\" (last column in the table). This allows for a single-character representation of each possible score — as a consequence, **each quality score character can conveniently correspond to (& line up with) a base character** in the read. (For your reference, [here is a complete lookup table](https://www.drive5.com/usearch/manual/quality_score.html) --- look at the top table, \"BASE=33\").\n:::\n\n<br>\n\n## Our FASTQ files\n\n### Listing your FASTQ files\n\nFirst, let's take another look at your list of FASTQ files:\n\n``` bash\nls -lh data/fastq\n```\n\n``` bash-out\ntotal 6.1G\n-rw-r--r-- 1 jelmer PAS2250 205M Feb  4 11:47 SM04_R1.fastq.gz\n-rw-r--r-- 1 jelmer PAS2250 242M Feb  4 11:46 SM04_R2.fastq.gz\n-rw-r--r-- 1 jelmer PAS2250 188M Feb  4 11:46 SM1030_R1.fastq.gz\n-rw-r--r-- 1 jelmer PAS2250 221M Feb  4 11:46 SM1030_R2.fastq.gz\n-rw-r--r-- 1 jelmer PAS2250 187M Feb  4 11:46 SM1031_R1.fastq.gz\n-rw-r--r-- 1 jelmer PAS2250 221M Feb  4 11:46 SM1031_R2.fastq.gz\n-rw-r--r-- 1 jelmer PAS2250 187M Feb  4 11:46 SM1038_R1.fastq.gz\n-rw-r--r-- 1 jelmer PAS2250 224M Feb  4 11:46 SM1038_R2.fastq.gz\n# [...output truncated...]\n```\n\nAs we discussed yesterday, in the file listing above:\n\n-   The files all have a `.gz` extension,\n    indicating they have been compressed with the gzip utility.\n-   There are two files per sample: `_R1` (forward reads) and `_R2` (reverse reads).\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Paired-end data\n\nAs mentioned, we'll be working with ***paired-end*** (PE) Illumina sequencing data.\nTherefore, we have two files for each sequenced sample:\n\n-   The file with **forward reads has `_R1`** (or sometimes `_1`) in its name, e.g. `SM04_R1.fastq.gz`\n-   The file with **reverse reads has `_R2`** (or sometimes `_2`) in its name, e.g. `SM04_R2.fastq.gz`\\\n    (i.e., the file name should be identical to that for the forward read, except for the read direction identifier).\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Viewing FASTQ files\n\nNext, we'll take a peak inside one of these FASTQ files.\n\n#### Basic commands to view files\n\nLet's consider our options to look inside one of these files:\n\n-   **`cat`** prints the entire contents of a file to screen --- probably not a good idea for such a large file.\n-   **`head`** and **`tail`** print just the first and last lines of a file, respectively, which could perhaps be a good start?\n\nLet's try to print 8 lines, which should show us two reads:\n\n``` bash\nhead -n 8 data/fastq/SM04_R1.fastq.gz\n```\n\n``` bash-out\n�\nԽے�8�E��_1f�\"�QD�J��D�fs{����Yk����d��*��\n|��x���l޴�j�N������?������ٔ�bUs�Ng�Ǭ���i;_��������������|<�v����3��������|���ۧ��3ĐHyƕ�bIΟD�%����Sr#~��7��ν��1y�Ai,4\nw\\]\"b�#Q����8��+[e�3d�4H���̒�l�9LVMX��U*�M����_?���\\[\"��7�s\\<_���:�$���N��v�}^����sw�|�n;<�<�oP����\ni��k��q�ְ(G�ϫ��L�^��=��<���K��j�_/�[ۭV�ns:��U��G�z�ݎ�j����&��~�F��٤ZN�'��r2z}�f\\#��:�9$�����H�݂�\"�@M����H�C�\n�0�pp���1�O��I�H�P됄�.Ȣe��Q�>���\n�'�;@D8���#��St�7k�g��|�A䉻���_���d�_c������a\\�|�_�mn�]�9N������l�٢ZN�c�9u�����n��n�`��\n\"gͺ�\n    ���H�?2@�FC�S$n���Ԓh�       nԙj��望��f      �?N@�CzUlT�&�h�Pt!�r|��9~)���e�A�77�h{��~��     ��\n# [...output truncated...]\n```\n\n<details>\n\n<summary>Ouch! 😳 What went wrong here? *(Click for the solution)*</summary>\n\nWhat happened here is that we are directly seeing the contents of the *compressed* file, which is simply not human-readable.\n\n</details>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nTo get around this, we might be inclined to **uncompress** these files, which we could do with the **`gunzip` command**. However, uncompressed files take up several times as much disk storage space as compressed ones.\n\nFortunately, we don't need to decompress them:\n- Almost any bioinformatics tool will accept compressed FASTQ files.\n- We can still view these files in compressed form, as shown below.\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n#### The `less` pager\n\nHere, we'll use the `less` command, which will automatically display gzip-compressed files in human-readable form --- let's try it:\n\n``` bash\nless -S data/fastq/SM04_R1.fastq.gz\n```\n\n::: {.callout-note collapse=\"true\"}\n#### Avoid line-wrapping with `less -S` *(Click to expand)*\n\nDepending on your zoom level and the length of reads in your FASTQ file, some lines may contain too many characters to fit on your screen. If that's the case, `less` will by default \"wrap\" those lines onto the next line on your screen, so characters won't run off the screen on the right-hand side.\n\nThat may be useful when the file contains text you're trying to read in full, but it is often confusing for files like FASTQ as well as for tabular files. That's why we turned off line-wrapping with the `-S` option.\n:::\n\n::: exercise\n#### {{< fa user-edit >}} **Exercise**: Explore the file with `less`\n\n`less` doesn't print stuff to screen but instead opens it in a \"pager\". After running the command above, you should be viewing the file inside the `less` pager.\n\nYou can move around in the file in several ways: by scrolling with your mouse, with up and down arrows, or, if you have them, <kbd>PgUp</kbd> and <kbd>PgDn</kbd> keys (also, <kbd>u</kbd> will move up half a page and <kbd>d</kbd> down half a page).\n\nIf you find yourself scrolling down and down to try and reach the **end of the file**, you can instead press <kbd>G</kbd> to go to the very end right away (and <kbd>g</kbd> to go back to the top).\n\nNotice you won't get your shell prompt back until you **press** <kbd>q</kbd> to quit `less`.\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n<br>\n\n## Running FastQC\n\n### Intro to FastQC\n\nFastQC is a ubiquitous tools for **quality control of FASTQ files**. Running FastQC or a similar program is the first step in nearly any high-throughput sequencing project. FastQC is also a good first example of a tool with a command-line interface.\n\nFor each FASTQ file, FastQC outputs an **HTML file** that you can open in your browser with about a dozen graphs showing different QC metrics. The most important one is the **per-base quality score graph** shown below.\n\n::: {#fig-fastqc layout-ncol=\"2\" layout-nrow=\"1\"}\n![](img/fastqc_good.png)\n\n![](img/fastqc_bad.png)\n\nA FastQC per-base quality score graph for files with reasonably good (left) and very poor (right) quality reads. The y-axis shows Phred quality scores (higher is better, see also the color-coding) and the x-axis shows the position along the read.\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Building our FastQC command\n\nTo run FastQC, we can use the command `fastqc`.\n\nIf you want to analyze one of your FASTQ files with default FastQC settings,\na complete FastQC command to do so would simply be `fastqc` followed by the name of the file:\n\n``` bash\n# (Don't run this)\nfastqc data/fastq/SM04_R1.fastq.gz\n```\n\nHowever, an annoying FastQC **default behavior** is that it writes its output files in the dir where the input files are --- in general, it's not great practice to directly mix your primary data and results like that!\n\nTo figure out how we can change that behavior, first consider that many commands and bioinformatics tools alike have an **option `-h` and/or `--help`** to print usage information to the screen.\n\nLet's try that:\n\n``` bash\nfastqc -h\n```\n``` bash-out\nbash: fastqc: command not found...\n```\n\nHowever, there is a wrinkle, as you can see above.\nWhile FastQC *is* installed at OSC[^2], we have to **\"load it\"** with the `module load` command before we can use it.\n\n[^2]: For a full list of installed software at OSC: <https://www.osc.edu/resources/available_software/software_list>\n\nHowever, we will be using a whole array of bioinformatics programs,\nand we are going to use a (nearly) one-stop solution:\na so-called \"Conda environment\" that has all of those programs installed.\n\n::: callout-tip\n#### Conda and software management\n\nWe won't have time to get into this now, but you want to learn more about Conda / software usage at supercomputers, see [this reference page elsewhere on the website](ref_software.qmd).\n:::\n\n**Here's how we can load that Conda software environment** ---\nwe first load OSC's (mini)conda installation,\nand then we can load (\"activate\") the Conda environment that I created for you:\n\n``` bash\nmodule load miniconda3\nsource activate /fs/ess/PAS0471/jelmer/conda/cabana\n```\n\n::: exercise\n#### {{< fa user-edit >}} **Exercise**: FastQC help and output dir\n\nAgain try to print FastQC's help info,\nand figure out which option you can use to specify a custom output directory.\n\n<details><summary>*Click for the solution*</summary>\n\n`fastqc -h` and `fastqc --help` will both work to show the help info.\n\nYou'll get quite a bit of output printed to screen,\nincluding the snippet about output directories that is reproduced below:\n\n``` bash\nfastqc -h\n```\n\n``` bash-out\n  -o --outdir     Create all output files in the specified output directory.\n                    Please note that this directory must exist as the program\n                    will not create it.  If this option is not set then the \n                    output file for each sequence file is created in the same\n                    directory as the sequence file which was processed.\n```\n\nSo, you can use `-o` or equivalently, `--outdir` to specify an output dir.\n\n</details>\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nWith the added `--outdir` (or `-o`) option, let's try to run the following FastQC command:\n\n``` bash\nfastqc \\\n  --outdir results/fastqc_pretrim \\\n  data/fastq/SM04_R1.fastq.gz\n```\n``` bash-out\nSpecified output directory 'results/fastqc_pretrim' does not exist\n```\n\n::: callout-note\n#### Spreading commands across multiple lines with `\\`\n\nAbove, I spread the command across multiple lines, which makes it a little easier to read. You can run the command exactly like that: we use the backslashes (**`\\`**) at the end of all but the last line to indicate to the shell that our command will continue on the next line.\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: exercise\n#### {{< fa user-edit >}} **Exercise**: Fixing the FastQC error\n\nNow what is going on this time? 😨 Or had you perhaps seen this coming given the help text we saw earlier? At any rate, can you try to fix the problem?\n\n<details>\n\n<summary>*Click here for a hint*</summary>\n\nYou'll need to create a new directory, which you can do either by using the buttons in the VS Code side bar, or with the `mkdir` command --- here, try it as **`mkdir -p`** followed by the name (path) of the directory you want to create.\n\n</details>\n\n<details>\n\n<summary>*Click here for the solution*</summary>\n\n-   The problem, as the error fairly clearly indicates, is that the output directory that we specified with `--outdir` does not currently exist. We might have expected FastQC to be smart/flexible enough to create this dir for us (many bioinformatics tools *are*), but alas. On the other hand, if we had read the help text clearly, it did warn us about this.\n\n-   With the `mkdir` command, to create \"two levels\" of dirs at once, like we need to here (both `results` and then `fastqc` within there), we need its `-p` option:\n\n``` bash\nmkdir -p results/fastqc_pretrim\n```\n\n</details>\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nAnd for our final try before we give up and throw our laptop out of the window (make sure to run the code in the exercise solution before you retry!):\n\n``` bash\nfastqc \\\n  --outdir results/fastqc_pretrim \\\n  data/fastq/SM04_R1.fastq.gz\n```\n\n``` bash-out\napplication/gzip\nStarted analysis of SM04_R1.fastq.gz\nApprox 5% complete for SM04_R1.fastq.gz\nApprox 10% complete for SM04_R1.fastq.gz\nApprox 15% complete for SM04_R1.fastq.gz\n[...truncated...]\nAnalysis complete for SM04_R1.fastq.gz\n```\n\nSuccess!! 🎉\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### FastQC output files\n\nLet's take a look at the files in the output dir we specified:\n\n``` bash\nls -lh results/fastqc_pretrim\n```\n\n``` bash-out\ntotal 1.2M\n-rw-r--r-- 1 jelmer PAS0471 713K Feb  4 14:02 SM04_R1_fastqc.html\n-rw-r--r-- 1 jelmer PAS0471 431K Feb  4 14:02 SM04_R1_fastqc.zip\n```\n\n-   There is a `.zip` file, which contains **tables** with FastQC's data summaries\n-   There is an `.html` (HTML) file, which contains **plots** --- this is what we'll look at next\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: exercise\n#### {{< fa user-edit >}} **Exercise**: Another FastQC run\n\nRun FastQC for the corresponding R2 FASTQ file. Would you use the same output dir?\n\n<details>\n\n<summary>*Click for the solution*</summary>\n\nYes, it makes sense to use the same output dir, since as you could see above, the output file names have the input file identifiers in them. As such, we don't need to worry about overwriting files, and it will be easier to have all the results in a single dir.\n\nTo run FastQC for the R2 (reverse-read) file:\n\n``` bash\nfastqc \\\n  --outdir results/fastqc_pretrim \\\n  data/fastq/SM04_R2.fastq.gz\n```\n``` bash-out\nStarted analysis of SM04_R2.fastq.gz\nApprox 5% complete for SM04_R2.fastq.gz\nApprox 10% complete for SM04_R2.fastq.gz\nApprox 15% complete for SM04_R2.fastq.gz\n[...truncated...]\nAnalysis complete for SM04_2.fastq.gz\n```\n\n``` bash\nls -lh results/fastqc_pretrim\n```\n\n``` bash-out\n-rw-r--r-- 1 jelmer PAS0471 241K Jan 21 21:50 SM04_R1_fastqc.html\n-rw-r--r-- 1 jelmer PAS0471 256K Jan 21 21:50 SM04_R1_fastqc.zip\n-rw-r--r-- 1 jelmer PAS0471 234K Jan 21 21:53 SM04_R2_fastqc.html\n-rw-r--r-- 1 jelmer PAS0471 244K Jan 21 21:53 SM04_R2_fastqc.zip\n```\n\nNow, we have four files: two for each of our preceding successful FastQC runs.\n\n</details>\n:::\n\n<br>\n\n## Interpreting FastQC output\n\n### FastQC HTML modules\n\nWe'll now go through a couple of the FastQC plots/modules,\nwith first some example plots^[\nAttribution: Some of the FastQC example plots were taken from [here](https://rtsf.natsci.msu.edu/sites/_rtsf/assets/File/FastQC_TutorialAndFAQ_080717.pdf).]\nwith good/bad results for reference.\n\n#### Overview of module results\n\nFastQC has \"**pass**\" (checkmark in green), \"**warning**\" (exclamation mark in orange), and \"**fail**\" (cross in red) assessments for each module, as you can see below.\n\nThese are handy and typically at least somewhat meaningful, but it is important to realize *that a \"warning\" or a \"fail\" is not necessarily the bad news that it may appear to be,* because, e.g.:\n\n-   Some of these modules could perhaps be called overly strict.\n-   Some warnings and fails are easily remedied or simply not a very big deal.\n-   FastQC assumes that your data is derived from whole-genome shotgun sequencing --- some other types of data like RNA-seq data will always trigger a couple of warnings and files based on expected differences.\n\n<p align=\"center\">\n\n<img src=\"img/fastqc_summary2.png\" width=\"30%\"/>\n\n</p>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n#### Basic statistics\n\nThis shows, for example, the number of sequences (reads) and the read length range for your file:\n\n<p align=\"center\">\n\n<img src=\"img/fastqc_mod01_basic-stats.png\" width=\"85%\"/>\n\n</p>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n#### Per base quality sequence quality\n\nThis figure visualize the mean per-base quality score (y-axis) along the length of the reads (x-axis). Note that:\n\n-   A decrease in sequence quality along the reads is normal.\n-   R2 (reverse) reads are usually worse than R1 (forward) reads.\n\n::: columns\n::: {.column width=\"50%\"}\n**Good / acceptable:**\n\n<p align=\"center\">\n\n<img src=\"img/fastqc_good.png\" width=\"100%\"/>\n\n</p>\n:::\n\n::: {.column width=\"50%\"}\n**Bad:**\n\n<p align=\"center\">\n\n<img src=\"img/fastqc_bad.png\" width=\"100%\"/>\n\n</p>\n:::\n:::\n\nTo interpret the quality scores along the y-axis, note the color scaling in the graphs (green is good, etc.), and see this table for details:\n\n| Phred quality score | Error probability | Rough interpretation |\n|---------------------|-------------------|----------------------|\n| **10**              | 1 in 10           | terrible             |\n| **20**              | 1 in 100          | bad                  |\n| **30**              | 1 in 1,000        | good                 |\n| **40**              | 1 in 10,000       | excellent            |\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n#### Per sequence quality scores\n\nThis shows the same quality scores we saw above, but now simply as a density plot of per-read averages, with the quality score now along the x-axis, and the number of reads with that quality score along the y-axis:\n\n::: columns\n::: {.column width=\"50%\"}\n**Good:**\n\n<p align=\"center\">\n\n<img src=\"img/fastqc_mod04_per-seq-qual_good.png\" width=\"100%\"/>\n\n</p>\n:::\n\n::: {.column width=\"50%\"}\n**Bad:**\n\n<p align=\"center\">\n\n<img src=\"img/fastqc_mod04_per-seq-qual_bad.png\" width=\"100%\"/>\n\n</p>\n:::\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n#### Sequence length distribution\n\nWill throw a warning as soon as not all sequences are of the same length (like below), but this is quite normal.\n\n<p align=\"center\">\n\n<img src=\"img/fastqc_mod08_seqlen_warning.png\" width=\"60%\"/>\n\n</p>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n#### Adapter content\n\nChecks for known adapter sequences. When some of the insert sizes are shorter than the read length, adapters can end up in the sequence – these should be removed!\n\n::: columns\n::: {.column width=\"50%\"}\n**Good:**\n\n<p align=\"center\">\n\n<img src=\"img/fastqc_mod11_adapter_good.png\" width=\"100%\"/>\n\n</p>\n:::\n\n::: {.column width=\"50%\"}\n**Bad:**\n\n<p align=\"center\">\n\n<img src=\"img/fastqc_mod11_adapter_bad.png\" width=\"100%\"/>\n\n</p>\n:::\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Checking your FastQC results\n\nFirst, you'll unfortunately have to download FastQC's output HTML files to your computer:\n\n-   Find the FastQC HTML files in the file explorer in the VS Code side bar.\n-   Right-click on one of them, click `Download...` and follow the prompt to download the file somewhere to your computer (doesn't matter where).\n-   Repeat this for the second file\n-   Then, open your computer's file browser, find the downloaded files, and double-click on one. It should be **opened in your default web browser**.\n\n::: exercise\n#### {{< fa user-edit >}} **Exercise**: Interpreting your FastQC results\n\n-   Open the HTML file for the R1 FASTQ file and go through the modules we discussed above. Can you make sense of it? Does the data look good to you, overall?\n\n-   Now open the HTML file for the **R2** FASTQ file and take a look just at the quality scores. Does it look any worse than the R1?\n:::\n\n<br>\n\n## Summarizing QC results with MultiQC\n\nHere are some challenges you may run into after running FastQC:\n\n- When you have many FASTQ files, you'll generate a lot of FastQC HTML files to sort through.\n  Our dataset is small with only 16 samples, but this still means 32 FastQC outputs.\n  Other datasets may easily have dozens or even hundreds of samples,\n  in which case checking all of the output becomes a very unpleasant task.\n\n- Even if you do diligently go through each file, it's not that easy to compare samples,\n  since they are not drawn in the same graphs.\n\nMultiQC addresses these problems as it aggregates FastQC results from many files,\nand summarizes them into a single HTML file with (still) one graph per FastQC module.\n\n::: callout-note\n#### Not just for FastQC results!\nAnd while MultiQC is most widely used for FastQC aggregation,\nit can recognize and process the (often \"log\"-type) output of dozens of bioinformatics tools,\nincluding several others that we will be using.\n:::\n\nMultiQC's graphs are also _interactive_, but here is a static example:\n\n![](img/multiqc_fastqc_per_base_sequence_quality_plot.png){fig-align=\"center\" width=\"95%\"}\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Running MultiQC\n\nTo run MultiQC, use the command `multiqc`.\nLet's start by running it with the `--help` option:\n\n```bash\nmultiqc --help\n# (Only the top part of the output is shown in the screenshot below)\n```\n\n![](img/multiqc_help.png){fig-align=\"center\" width=\"100%\"}\n\nAs the first couple of help lines in the paler gray color explain,\nMultiQC will search the `[ANALYSIS DIRECTORY]`, a dir that we pass to it as an argument\nat the end of the command line.\n\nThat is, if we tell MultiQC about the `results/fastqc_pretrim` directory like so,\nit should find and then aggregate all the FastQC results in there:\n\n```bash\n# (Don't run this - we'll complete the command in a second)\nmultiqc /fs/scratch/PAS2250/cabana/bact_results/fastqc_pretrim\n```\n\n::: callout-note\n#### Since you ran FastQC on only sample, we'll be using the FastQC results for all files that I generated for you.\n:::\n\nThe default output directory of MultiQC is the current working directory,\nso just like with FastQC, we do want to use that option as well^[\nI will specify the dir `results/multiqc_fastqc`,\nindicating that this is a MultiQC run that summarizes FastQC output]:\n\n```bash\n# Run MultiQC to summarize the FastQC results\nmultiqc \\\n  --outdir results/multiqc_fastqc \\\n  /fs/scratch/PAS2250/cabana/bact_results/fastqc_pretrim\n```\n\n![](img/multiqc_stdout.png){fig-align=\"center\" width=\"100%\"}\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### MultiQC output\n\nThen, you should have some files in the output dir:\n\n```bash\nls -lh results/multiqc_fastqc\n```\n``` bash-out\ntotal 1.7M\ndrwxr-xr-x 2 jelmer PAS2250 4.0K Feb  4 14:57 multiqc_data\n-rw-r--r-- 1 jelmer PAS2250 1.7M Feb  4 14:57 multiqc_report.html\n```\n\nGo ahead and find the HTML file in VS Code's file browser, right-click on it and then \ndownload it to your computer, and click on the file in your own computer to open\nit in your browser (i.e., just like we did with the FastQC output).\n\n::: exercise\n#### {{< fa user-edit >}} **Exercise**: Explore the MultiQC results\n\nCheck for example whether patterns are consistent across samples,\nor if there are any outliers.\n\n:::\n\n<br>\n\n## Trimming with TrimGalore\n\nWe will run TrimGalore to filter our FASTQ files, removing:\n\n- Any adapter sequences that may be present in the reads\n- Poor-quality bases at the start and end of the reads\n- Very short reads (in most cases made short by the prior two steps)\n\n::: {.callout-note collapse=\"true\"}\n#### Alternative trimming programs _(Click to expand)_\n\nSeveral largely equivalent tools exist for this kind of FASTQ preprocessing ---\n_Trimmomatic_ and _fastp_ are two other commonly used ones.\n(And TrimGalore itself is mostly a wrapper around another tool called _CutAdapt_.)\n\nTwo advantages of of TrimGalore are that it will **auto-detect the adapters** that\nare present in your reads\n(e.g., different library prep protocols use different adapters),\nand that it can **automatically run _FastQC_** on the processed sequences.\n:::\n\nUnfortunately, we'll first have to switch Conda environments for TrimGalore:\n\n```bash\nsource activate /fs/ess/PAS0471/jelmer/conda/trimgalore\n```\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Running TrimGalore\n\nWe will run TrimGalore for one sample, but because we have paired-end reads:\n\n- We'll specify two FASTQ file names:\n  one with the forward (R1) reads, and one with the reverse (R2) reads.\n- We'll have to use the `--paired` option (see the box below for details if you're interested)\n\n::: {.callout-note collapse=\"true\"}\n#### More on paired-end trimming _(Click to expand)_\n\nWhen we have paired-end reads,\nmuch of the trimming happens separately for the R1 (forward) and R2 (reverse) files,\nbut at the end of the run,\nTrimGalore will make sure that every R1 read still has its R2 counterpart, and vice versa.\n\nHowever, we have to use the `--paired` option for this: without it,\nTrimGalore will _only_ process the R1 and R2 files separately,\nand omit the final step where it removes orphaned reads.\n\nWith the `--paired` option, any \"orphaned\" reads will by default be removed,\nbecause R1 and R2 files for the same samples always need to contain all the same reads.\n(TrimGalore does have an option to retain these orphaned reads into _separate_ files,\nbut we won't use that.)\n:::\n\nSo far, our command looks like this:\n\n```bash\n# (Don't run this)\ntrim_galore \\\n  --paired \\\n  data/fastq/SM04_R1.fastq.gz \\\n  data/fastq/SM04_R2.fastq.gz\n```\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nIn terms of other TrimGalore options:\n\n- Use the default settings for adapters (auto-detection and removal) and\n  the base quality threshold (a Phred score of 20)\n- Use a longer read length (36 bp) than the default of 36 bp: **`--length 36`**.\n- Specify the output directory^[Once again, the default output dir is\n  the current working dir which is not convenient]: **`--output_dir results/trimgalore`**.\n- Have TrimGalore run _FastQC_ for us on the filtered FASTQ files,\n  so we can e.g. check if adapters were successfully removed.\n\n::: {.callout-tip collapse=\"true\"}\n#### Checking the TrimGalore help _(Click to expand)_\n\nYou might also want to run TrimGalore with the `--help` option to learn how to run it:\n\n```bash\ntrim_galore --help\n# Note: Below I am only showing (truncated) output for the key options!\n```\n```{.bash-out}\n USAGE:\ntrim_galore [options] <filename(s)>\n\n--paired                This option performs length trimming of quality/adapter/RRBS trimmed reads for\n                        paired-end files.\n-o/--output_dir <DIR>   If specified all output will be written to this directory instead of the current\n                        directory. If the directory doesn't exist it will be created for you.\n--fastqc                Run FastQC in the default mode on the FastQ file once trimming is complete.\n--fastqc_args \"<ARGS>\"  Passes extra arguments to FastQC.\n-a/--adapter <STRING>   Adapter sequence to be trimmed. If not specified explicitly, Trim Galore will\n                        try to auto-detect whether the Illumina universal, Nextera transposase or Illumina\n                        small RNA adapter sequence was used.\n-q/--quality <INT>      Trim low-quality ends from reads in addition to adapter removal.\n--length <INT>          Discard reads that became shorter than length INT because of either\n                        quality or adapter trimming. A value of '0' effectively disables\n                        this behaviour. Default: 20 bp.\n```\n:::\n\nA final test command to run TrimGalore on our actual (but small, subsetted)\nFASTQ files in `data/fastq` could therefore look as follows:\n\n```bash\n # Once again, we have to make the FastQC outdir!\nmkdir results/fastqc_posttrim\n\n# Run TrimGalore\ntrim_galore \\\n    --paired \\\n    --length 36 \\\n    --output_dir results/trimgalore \\\n    --fastqc_args \"--outdir results/fastqc_posttrim\" \\\n    data/fastq/SM04_R1.fastq.gz \\\n    data/fastq/SM04_R2.fastq.gz\n```\n```bash-out\nMulticore support not enabled. Proceeding with single-core trimming.\nPath to Cutadapt set as: 'cutadapt' (default)\nCutadapt seems to be working fine (tested command 'cutadapt --version')\nCutadapt version: 4.4\nsingle-core operation.\nigzip command line interface 2.30.0\nigzip detected. Using igzip for decompressing\n\nNo quality encoding type selected. Assuming that the data provided uses Sanger encoded Phred scores (default)\n\nOutput directory results/trimgalore/ doesn't exist, creating it for you...\n\nOutput will be written into the directory: /fs/scratch/PAS2250/cabana/jelmer/bact/results/trimgalore/\n\nAUTO-DETECTING ADAPTER TYPE\n===========================\nAttempting to auto-detect adapter type from the first 1 million sequences of the first file (>> data/fastq/SM04_R1.fastq.gz <<)\n# [...output truncated...]\n```\n\n::: callout-note\n#### Trimming strictness\nThe exact choice of trimming strictness parameters,\nespecially regarding the minimum read length and minimum base quality is fairly arbitrary,\nand may not have a large effect on the final assembly.\nThat said, while read lengths of 20 may still be useful in a read mapping context,\nthey are less so in a de novo assembly context, so we use a higher read length threshold. \n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### TrimGalore output\n\nAfter you ran the command above, a lot of logging output should have been printed to screen.\n\nFor example, it reports the adapter that it detected,\nthe final parameters passed to Cutadapt (which does the actual trimming),\nand results on how much sequence was removed.\n\n::: exercise\n#### {{< fa user-edit >}} **Exercise**: Check the TrimGalore logging output\n\nLook for `=== Summary ===` sections (two of them, one for the R1 and one for the R2)\nto answer the following questions:\n\n- What percentage of the reads had adapter sequences?\n- What percentage of basepairs were quality-trimmed from the R1 and R2 files,\n  respectively?\n\nLook near the end of the output to answer the following question:\n  \n- How many reads were removed due to the length-filter?\n\n<details><summary>_Click for the solution_</summary>\nSome of the more relevant information that should have been printed:\n\n- For the R1 file:\n\n```bash-out\n=== Summary ===\n\nTotal reads processed:               1,031,129\nReads with adapters:                   398,726 (38.7%)\nReads written (passing filters):     1,031,129 (100.0%)\n\nTotal basepairs processed:   275,173,541 bp\nQuality-trimmed:               7,733,000 bp (2.8%)\nTotal written (filtered):    266,857,947 bp (97.0%)\n```\n\n- For the R2 file:\n\n```bash-out\n=== Summary ===\n\nTotal reads processed:               1,031,129\nReads with adapters:                   424,883 (41.2%)\nReads written (passing filters):     1,031,129 (100.0%)\n\nTotal basepairs processed:   276,647,678 bp\nQuality-trimmed:              42,814,676 bp (15.5%)\nTotal written (filtered):    233,141,370 bp (84.3%)\n```\n\n- And at the end:\n\n```bash-out\nNumber of sequence pairs removed because at least one read was shorter than the length cutoff (36 bp): 6672 (0.65%)\n```\n\n</details>\n\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nMuch of the above information is also saved in the output dir in files that end in\n`*_trimming_report.txt`.\n\nThe main output files, however, are a new pair of FASTQ files with trimmed reads ---\nwe will use those FASTQ files for the next step (assembly).\nLet's take a look:\n\n```bash\nls -lh results/trimgalore\n```\n```bash-out\ntotal 342M\n-rw-r--r-- 1 jelmer PAS0471 5.2K Feb  4 16:48 SM04_R1.fastq.gz_trimming_report.txt\n-rw-r--r-- 1 jelmer PAS0471 169M Feb  4 16:52 SM04_R1_val_1.fq.gz\n-rw-r--r-- 1 jelmer PAS0471 5.2K Feb  4 16:52 SM04_R2.fastq.gz_trimming_report.txt\n-rw-r--r-- 1 jelmer PAS0471 174M Feb  4 16:52 SM04_R2_val_2.fq.gz\n```\n\nAlso, we should have FastQC output files that will be good to check:\n\n```bash\nls -lh results/fastqc_posttrim\n```\n```bash-out\ntotal 2.4M\n-rw-r--r-- 1 jelmer PAS0471 705K Feb  4 17:00 SM04_R1_val_1_fastqc.html\n-rw-r--r-- 1 jelmer PAS0471 437K Feb  4 17:00 SM04_R1_val_1_fastqc.zip\n-rw-r--r-- 1 jelmer PAS0471 724K Feb  4 17:01 SM04_R2_val_2_fastqc.html\n-rw-r--r-- 1 jelmer PAS0471 470K Feb  4 17:01 SM04_R2_val_2_fastqc.zip\n```\n\n::: exercise\n#### {{< fa user-edit >}} **Exercise**: Check the trimming results with FastQC\n\n- Check the FastQC output HTML to see if adapters were removed,\n  and if the overall quality looks better.\n:::\n\n<br><br>\n\n---------------\n\n<br><br>\n\n## Appendix\n\n### `zcat` and related commands\n\n`cat` has a counterpart that prints the uncompressed contents of a compressed file: **`zcat`**.\n\nOf course, `cat`'s behavior of printing all the contents of a file isn't great for large FASTQ files. But `zcat` is nevertheless very useful for FASTQ files when we **combine it with the pipe, `|`**.\n\nFor example, we can pipe the output of `zcat` to the `head` command to view the first 8 lines (2 reads) as follows:\n\n``` bash\nzcat data/fastq/SM04_R1.fastq.gz | head -n 8\n```\n\n``` bash-out\n@M06129:165:000000000-K9L4J:1:1101:13571:1001 1:N:0:24\nNTGCTGACATCCACTATTGAGCCCATCAGGAACCGAGCATGTCAGACGCTATTCACTCCTACGAGCCATCCAAGGGTCACGGCCTGCCGCACGACCCGTTCAACGCGATTGTAGGCCCACGCCCGATTGGCTGGATTTCGTCGCAGGATGCCAACGGCAAACTCAACCTGGCACCTTACAGCTTCTTCAACGCGTTCAACTACGTGCCGCCGATCATCGGCTTCTGCAGCGTGGGTCGCAAAGACAGCCTCAATAATATCGAGCAAACCGGCCAGTTCGTCTGGAACCTGGCGACCCGCC\n+\n#8ACCGGGFGGGGGGGGDGGGGEGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGEGGGGGGGGGGGGGGGGGGCFGGGGGGGGGGGF:FDFGD@FFGGGGGGGDG=FDGFF=FGGFFGCFFGFGGGEGGGGCAFGGGGGDGGEEEFFGGGFGGD>8DFGGGGGGGFGFGGC55CCEEFGGGG?<FGGGGGGGGDGGGFC<D7;FGFG?F?EDFF:>55;>;B@(06::?(37?>FA46)4.,(,4<??B(1((-1,640-,.(34,(-(.(14,(3((((\n@M06129:165:000000000-K9L4J:1:1101:9227:1001 1:N:0:24\nNGAAACCTATGGTTTCGTCAATCGCCTTGCAGACGGTCGCTACATGCTCGCGAGCGAAGTCATGCGCCTCAATGCGGTCTATCAGGATGCCCTGGATCTTGAGCGGCATGTGTTGCCAAGGTTGCACAAGCTGACCGGAGAAACCGGCGAGACCGCCTCTTTTTATGTGAAACACGGTGCCTATCGGTTGTGTCAGTACCGGGTCAACTCTCCTCACCGTCTGCGATTGCACATGCAGCCTGGAGACATGCGCCCCATGGACGGTGCGGCGAGTGCCGAAGCATTGCGTACACCGTATGC\n+\n#8BCCGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGFGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGDGGGGGGGGGGGGGGGGGGCGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGDEFGGGGDGGGGGGGGGGGFFGBGFFFFFFFFFFFFFFFF<FFFFF<>9EFFFFFBBF?BFFBF9;61364,6A9;B>BF<A?<<9(((.:;?::?F\n```\n\nAlong the same lines, we can count the number of lines in a FASTQ file like so:\n\n``` bash\nzcat data/fastq/SM04_R1.fastq.gz | wc -l\n```\n\n``` bash-out\n4124516\n```\n\n::: {.callout-note collapse=\"true\"}\n##### More about the Unix pipe, `|` *(Click to expand)*\n\nThe **`|` (pipe)** takes the output of one command and passes it on (\"pipes\") as input for a subsequent command.\n\nThe most common way to use many shell commands that take input (which is most of them) is to pass that input as a file name --- below, `wc -l` will operate on the FASTA file:\n\n``` bash\nwc -l data/fastq/SM04_R1.fastq.gz \n```\n\nHowever, `wc -l` (and almost any other command) will also operate on input that is passed to it though a pipe, so the above and below are completely equivalent:\n\n``` bash\ncat data/fastq/SM04_R1.fastq.gz | wc -l\n```\n\nThe pipe is incredibly useful because it avoids the need write/read intermediate files — this saves typing and also makes the operation much quicker.\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: exercise\n#### {{< fa user-edit >}} **Exercise** : The number of reads in a FASTQ file\n\n-   Given the output of the command above, how many reads are in this FASTQ file?\n\n<details>\n\n<summary>Solution</summary>\n\nThere are 4,124,516 / 4 = 1,031,129 reads in this file, so a little more than a million.\n\n</details>\n\n-   What line count do you get when you run `wc -l` directly on the compressed file?\n\n<details>\n\n<summary>Solution</summary>\n\nYou'll get a line count of 880,721, quite a ways off from the number of lines in the uncompressed file! So, don't do this when you want to count lines/reads!\n\n``` bash\nwc -l data/fastq/SM04_R1.fastq.gz \n```\n\n``` bash-out\n880721 data/fastq/SM04_R1.fastq.gz\n```\n\n</details>\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}