{
  "hash": "79e6b7a6a162a5b5691f1b9061c0a368",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Trimming with _TrimGalore_\"\npagetitle: \"TrimGalore\"\nhighlight-style: github\nnumber-sections: true\nengine: knitr\nauthor: Jelmer Poelstra\ndate: 2023-10-13\n---\n\n\n\n\n-------\n\n<br>\n\n## Overview & setting up {-}\n\nIn this tutorial, we will run _TrimGalore_ to filter our FASTQ files, removing:\n\n- Any adapter sequences that are present in the reads\n- Poor-quality bases at the start and end of the reads\n- Reads that have become very short after the prior two steps\n\nFor reference-based RNAseq, this step is sometimes considered optional,\nsince current tools that align reads to the genome\nshould generally be able to deal with poor-quality bases and adapter sequences.\n\nSeveral largely equivalent tools exist for this kind of FASTQ preprocessing ---\n_Trimmomatic_ and _fastp_ are two other commonly used ones.\n_TrimGalore_ itself is in fact \"just\" a wrapper around another tool called _CutAdapt_,\nbut it is much simpler to use.\nTwo advantages of of _TrimGalore_ are that it will auto-detect the adapters that\nare present in your reads\n(e.g., different library prep protocols use different adapters),\nand that it can automatically run _FastQC_ on the processed sequences.\n\n<br>\n\n## Using TrimGalore at OSC\n\n_TrimGalore_ isn't installed at OSC,\nso we'll use my _Conda_ environment for _TrimGalore_ like we did with _MultiQC_:\n\n```bash\nmodule load miniconda3\nsource activate /fs/ess/PAS0471/jelmer/conda/trimgalore\n```\n\nLet's see if we can now run it &mdash;\nnote that the command is `trim_galore` with an underscore:\n\n```bash\ntrim_galore --version\n```\n```{.bash-out}\n\n            Quality-/Adapter-/RRBS-/Speciality-Trimming\n                    [powered by Cutadapt]\n                        version 0.6.10\n\n                    Last update: 02 02 2023\n```\n\n::: {.callout-note collapse=\"true\"}\n#### How you can create your own TrimGalore Conda environment (click to expand) \n\n```bash\n# Make sure the load the latest miniconda version when doing installations\nmodule load miniconda3/23.3.1-py310\n\n# Create a new environment called 'trimgalore' and install the program into it\n# (Yes, the Conda package is named 'trim-galore' with a dash!)\nconda create -y -n trimgalore -c bioconda trim-galore\n```\n:::\n\n<br>\n\n## TrimGalore syntax\n\nLet's run _TrimGalore_ with the `--help` option to get some information about\nhow we can run it:\n\n```bash\ntrim_galore --help\n\n# Note: Below I am only showing (truncated) output for the key options!\n```\n```{.bash-out}\n USAGE:\ntrim_galore [options] <filename(s)>\n\n--paired                This option performs length trimming of quality/adapter/RRBS trimmed reads for\n                        paired-end files.\n\n-o/--output_dir <DIR>   If specified all output will be written to this directory instead of the current\n                        directory. If the directory doesn't exist it will be created for you.\n\n-j/--cores INT          Number of cores to be used for trimming [default: 1].\n\n--fastqc                Run FastQC in the default mode on the FastQ file once trimming is complete.\n\n--fastqc_args \"<ARGS>\"  Passes extra arguments to FastQC.\n\n-a/--adapter <STRING>   Adapter sequence to be trimmed. If not specified explicitly, Trim Galore will\n                        try to auto-detect whether the Illumina universal, Nextera transposase or Illumina\n                        small RNA adapter sequence was used.\n\n-q/--quality <INT>      Trim low-quality ends from reads in addition to adapter removal.\n\n--length <INT>          Discard reads that became shorter than length INT because of either\n                        quality or adapter trimming. A value of '0' effectively disables\n                        this behaviour. Default: 20 bp.\n```\n\nThe line below \"USAGE:\" tells us that the FASTQ file names should be specified\nas **positional arguments at the end of the command**.\n\n**We will run TrimGalore for one sample at a time**,\nbut this means having to specify two FASTQ file names:\none with the forward reads, and one with the reverse reads.\nWhen we have paired-end reads,\nmuch of the trimming happens separately for the R1 (forward) and R2 (reverse) files,\nbut at the end of the run,\nTrimGalore will make sure that every R1 read still has its R2 counterpart,\nand vice versa.\nAny \"orphaned\" reads will by default be removed,\nbecause R1 and R2 files for the same samples always need to contain all the same reads.\n(TrimGalore does have an option to retain these orphaned reads into _separate_ files.)\n\nNone of the **options** are required,\nas the square brackets around `[options]` indicate,\nbut any option we may want to use should be placed _after_ the `trim_galore`\ncommand and _before_ the FASTQ file name(s).\nWith paired-end reads, _we'll have to use the `--paired` option_ ---\notherwise, TrimGalore will only process the R1 and R2 separately\nand omit the final step where it removes orphaned reads.\n\n<br>\n\n## Building our _TrimGalore_ command\n\nGiven what we discussed above,\na minimal functional example of a TrimGalore command would be  \n(with fictional FASTQ files `A_R1.fastq.gz` and `A_R2.fastq.gz`):\n\n```bash\n# (Don't run this, fictional example command)\ntrim_galore --paired A_R1.fastq.gz A_R2.fastq.gz\n```\n\nAs for other TrimGalore options:\n\n- We will use TrimGalore with **default settings** for the following options\n  (i.e., we will not use these options in our command):\n\n  - The trimming of adapters (`--adapter` option, default: auto-detect the adapters used)\n  - The minimum base quality threshold (`--quality` option, default: Phred score of 20)\n  - The minimum read length threshold (`--length` option, default: 20 bp)\n\n    ...but it's good to know we could easily change those if we wanted to.\n\n- We do want to specify the **output directory**,\n  since it's pretty inconvenient to have the output files placed in the current working dir,\n  as is the TrimGalore default.\n  We could for instance use **`--output_dir results/trimgalore`**.\n\n- We'll typically also want to have _TrimGalore_ **run _FastQC_** on the filtered FASTQ files,\n  since it will be good to check if adapter sequences were successfully removed, and so on.\n  \n  When we do so, we'll also have to tell _FastQC_ about the output dir of its files:\n  we can do so via `--fastqc_args`\n  (and using that option will already trigger the running of _FastQC_, i.e.,\n  there is then no need to also use the `--fastqc` option).\n  \n  So, we could use **`--fastqc_args \"--outdir results/trimgalore/fastqc\"`**.\n\n- Finally, we'll usually want to specify the number of cores/threads/CPUs,\n  and it should correspond to what we have available for our compute job.\n  Since we have 1 core available in the VS Code session,\n  we'll use **`--cores 1`** in the test-run, but something else in our final script.\n\nA final test command to run TrimGalore on our actual (but small, subsetted)\nFASTQ files in `data/fastq` could therefore look as follows:\n\n```bash\n# For clarity, I am specifying each option on a separate line\ntrim_galore \\\n    --paired \\\n    --output_dir results/trimgalore \\\n    --cores 1 \\\n    --fastqc_args \"--outdir results/trimgalore/fastqc\" \\\n    data/fastq/ASPC1_A178V_R1.fastq.gz data/fastq/ASPC1_A178V_R2.fastq.gz\n```\n\nLet's try that out.\n\n<br>\n\n## _TrimGalore_ output\n\nAfter you ran the line above,\nquite a lot of logging output should have been printed to screen.\nIf we take a look at that output:\n\n- The first section of interest is \"AUTO-DETECTING ADAPTER TYPE\",\n  where we can see that TrimGalore detected the \"Illumina adapter\"\n  and will use that for trimming.\n\n- After that, the section \"SUMMARISING RUN PARAMETERS\" tells us what the final\n  parameters (settings) are for running Cutadapt,\n  which will do the actual trimming.\n  We can for example see which base quality and read length parameters are\n  being used (the defaults, in this case).\n\n- Then, ... \n\nThe log for each FASTQ file is also saved to the output dir in files named `XXX`.\nCuriously, though, logging output that is not R1/R2-specific,\nlike that reporting on the final removal of orphaned reads, is not.\nAs such, when we will run TrimGalore by submitting batch jobs in a minute,\nand the logging output that was now printed to screen will go to a Slurm log file,\nit is a good idea to **keep these Slurm files**.\n\nLet's take a look at what files have been added to our output dir:\n\n```bash\nls -lh results/trimgalore\n```\n\n<br>\n\n## A script to run TrimGalore\n\nTo run _TrimGalore_ efficiently at OSC,\nwe will submit a separate compute job for each sample,\nand submit these all at the same time using a `for` loop in which we pass arguments\nto the script.\n\nThis is quite similar to how we ran FastQC.\nHowever, one added complication is that we now have to work with _two FASTQ files_\n(an R1 and R2 file for the same sample) at the same time.\n\n### Dealing with two FASTQ files per run\n\nThere are several different ways of dealing with having to run TrimGalore not for one\nbut for two files at the same time, but we'll do it as follows:\nwe'll only pass an R1 FASTQ filename to the script,\n_and the script will then infer the name of the R2 file_ (by replacing `_R1` with `_R2`).\nThis is generally the easiest method,\nbecause it allows us to simply loop over the R1 FASTQ files in our \"runner script\".\n\nThat is, in our `run.sh` script,\nthe code to submit the TrimGalore scripts would look as follows:\n\n```bash\n# We're only looping over the R1 files: we include the R2 files _inside_ the script\nfor R1 in data/fastq/*_R1.fastq.gz; do\n    sbatch scripts/trimgalore.sh $R1 results/trimgalore\ndone\n```\n\nHere is how we can include the R2 files inside the script:\n\n```bash\n# Arguments passed to the script include the R1 filename,\nR1=$1                # \"$1\" will for example be data/fastq/ASPC1_A178V_R1.fastq.gz\n# ....\n\n# Infer the name of the corresponding R2 file:\nR2=${R1/_R1/_R2}     # \"$2\" will then be data/fastq/ASPC1_A178V_R2.fastq.gz\n```\n\nThe funny-looking `${R1/_R1/_R2}` bit does a search-and-replace in the value\nof the `$R1` variable (this is called \"_parameter expansion_\"),\nand assigns the output to a new variable `$R2`: \n\n- Take the `$R1` variable, using the long notation `${R1}`\n- After the first forward slash, we enter the search pattern: `_R1`\n- After the second forward slash, we enter the replacement: `_R2`.\n\nLet's practice with parameter expansion:\n\n```bash\nfilename1=myfile.txt\nfilename2=${filename1/.txt/_copy.txt}\n\necho $filename2\n```\n```{.bash-out}\nmyfile_copy.txt\n```\n\n### Using multiple threads\n\nWhen we ran FastQC, we already practiced with using multiple threads/cores/cpus\n(remember, these are all all equivalent for our purposes here),\nwhich always involves two steps:\n\n- Requesting the desired number of threads for the Slurm job,\n  e.g. a line `#SBATCH --cpus-per-node=8` at the top of your script.\n\n- Telling the bioinformatics tool that it can use that same number of threads,\n  e.g. with `--cores 8` in the case of TrimGalore.\n\nSo, you're always specifying your desired number of cores in (at least) two \ndifferent places.\nAs such, there is the possibility that you're accidentally specifying a different\nnumber in the two places, e.g. when you want to change the number but only\ndo so in one of these two places.\n\nLet's introduce a trick you can use to automatically make sure that the\nnumber of threads is the same in both places,\nby using the Slurm \"environment variable\" `$SLURM_CPUS_ON_NODE`.\nWhen you run a Slurm job and you've requested a number of threads with \n`--cpus-per-node`, then this variable will always be set automatically.\n(In fact, there are many Slurm variables,\nsee [this section](https://slurm.schedmd.com/sbatch.html#SECTION_INPUT-ENVIRONMENT-VARIABLES)\nin the Slurm documentation for more information.)\n\nHere's how we can use this environment variable in practice:\n\n```bash\n#SBATCH --cpus-per-node=8\n\n# [...]\ntrim_galore \\\n    --cores \"$SLURM_CPUS_ON_NODE\" \\\n\n# [...]\n```\n\n### Our final TrimGalore command\n\nLike we've done in our FastQC and MultiQC scripts,\nwe'll also include an argument with the output directory name,\nas it is good practice not to hardcode this in your script.\n\nWith that, our final TrimGalore will be:\n\n```bash\ntrim_galore \\\n    --paired \\\n    --output_dir \"$outdir\" \\\n    --cores \"$SLURM_CPUS_ON_NODE\" \\\n    --fastqc_args \"--outdir \"$outdir\"/fastqc\" \\\n    \"$R1\" \"$R2\"    \n```\n\n### Renaming the output files\n\nOne annoying aspect of _TrimGalore_ is that it will give the output FASTQ files\nsuffixes --- here are the output files of our earlier test run:\n\n```bash\nASPC1_A178V_R1_val_1.fq.gz\nASPC1_A178V_R2_val_2.fq.gz\n```\n\nFirst, the extension is `.fq` instead of `.fastq`,\nand second, there are `_val_1` / `_val_2` additions to the filename.\nWith filenames like that, we would need to modify our globbing patterns\n(e.g. `*_R1.fastq.gz`) in the next step in our workflow.\nThis is of course possible and not even hard, per se, but it is inconvenient ---\nand in practice, these kind of inconsistencies easily end up leading to confusion and errors. \n\nTherefore, I usually choose to rename TrimGalore's output files inside the script,\nand give **the output files the exact same name as the input files**.\nWe can do so as follows:\n\n```bash\nfile_id=$(basename \"$R1\" _R1.fastq.gz)\n\nR1_out=\"$outdir\"/\"$file_id\"_R1_val_1.fq.gz\nR2_out=\"$outdir\"/\"$file_id\"_R2_val_2.fq.gz\n\nmv -v \"$R1_out\" \"$outdir\"/\"$file_id\"_R1.fastq.gz\nmv -v \"$R2_out\" \"$outdir\"/\"$file_id\"_R2.fastq.gz\n```\n\n::: {.callout-tip}\n#### Command substitution\nThe first line in the code block above used a construct called\n\"command substitution\",\nwhich allows you to save the output of a command in a variable.\nTo understand this better, please refer to this\n[at-home reading section in module A07](A07_overview.qmd#at-home-reading-command-substitution).\n:::\n\nOne thing that we do need to be wary of, however,\nwhen we give the output FASTQ files the same name as the input files,\nis that we don't overwrite the output files.\nIn general with these kind of scripts,\nyou don't want the output dir to be the same as the input dir,\nand as long as that is the case, the input files won't be overwritten.\nBut here,\nwe should really make _absolutely_ sure that the input dir isn't the same as\nthe output dir inside the script, and we can do so as follows:\n\n```bash\n# Check that the output dir isn't the same as the input dir\n# This is because we will let the output files have the same name as the input files\nif [[ $(dirname \"$R1\") == \"$outdir\" ]]; then\n    echo \"# ERROR: Input dir is the same as the output dir ($outdir)\" \n    exit 1\nfi\n```\n\nThere are several new things here:\n\n- If statement\n- `dirname` command\n- `exit 1`\n\n<br>\n\n## The final script to run TrimGalore\n\n```bash\n#!/bin/bash\n#SBATCH --account=PAS0471\n#SBATCH --time=1:00:00\n#SBATCH --cpus-per-task=8\n#SBATCH --mem=32G\n#SBATCH --job-name=trimgalore\n#SBATCH --output=slurm-trimgalore-%j.out\n\n# Copy the placeholder variables\nR1=$1\noutdir=$2\n\n# Load the Conda environment\nmodule load miniconda3\nsource activate /fs/ess/PAS0471/jelmer/conda/trimgalore\n\n# Use strict Bash settings\nset -euo pipefail\n\n# Infer derived variables\nR2=${R1/_R1/_R2}\n\n# Report\necho \"# Starting script trimgalore.sh\"\ndate\necho \"# Input R1 FASTQ file:      $R1\"\necho \"# Output dir:               $outdir\"\necho\n\n# Check that the output dir isn't the same as the input dir\n# This is because we will let the output files have the same name as the input files\nif [[ $(dirname \"$R1\") == \"$outdir\" ]]; then\n    echo \"# ERROR: Input dir is the same as the output dir ($outdir)\" \n    exit 1\nfi\n\n# Create the output dir\nmkdir -p \"$outdir\" \"$outdir\"/fastqc\n\n# Run TrimGalore\ntrim_galore \\\n    --paired \\\n    --output_dir \"$outdir\" \\\n    --cores \"$SLURM_CPUS_ON_NODE\" \\\n    --fastqc_args \"--outdir $outdir/fastqc\" \\\n    \"$R1\" \"$R2\"\n\n# Rename output files\necho -e \"\\n# Renaming the output files:\"\nfile_id=$(basename \"$R1\" _R1.fastq.gz)\nR1_out=\"$outdir\"/\"$file_id\"_R1_val_1.fq.gz\nR2_out=\"$outdir\"/\"$file_id\"_R2_val_2.fq.gz\nmv -v \"$R1_out\" \"$outdir\"/\"$file_id\"_R1.fastq.gz\nmv -v \"$R2_out\" \"$outdir\"/\"$file_id\"_R2.fastq.gz\n\n# Report\necho -e \"\\n# Done with script trimgalore.sh\"\ndate\necho -e \"\\n# Listing files in the output dir:\"\nls -lh \"$outdir\"\n```\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}