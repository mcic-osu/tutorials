{
  "hash": "c95c3fc783099fcc8edb1540ab7ee36c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data frame manipulation with _dplyr_\"\nauthor: \"Software Carpentry / Jelmer Poelstra\"\ndate: 2025-02-11\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n-------\n\n<br>\n\n## Introduction\n\n### The _dplyr_ package and the tidyverse\n\nThe [_dplyr_](https://cran.r-project.org/package=dplyr) package provides a number\nof very useful functions for **manipulating data frames**.\n\nIn this session, we'll cover some of the most commonly used functions:\n\n- `select()` to pick columns (variables)\n- `filter()` to pick rows (observations)\n- `rename()` to change column names\n- `arrange()` to change the order of rows (i.e., to sort a data frame)\n- `mutate()` to modify values in columns and create new columns\n- `summarize()` to compute across-row summaries\n\nAll these functions take a\n**data frame as the _input_, and output a new, modified data frame**.\n\n_dplyr_ belongs to a family of R packages designed for \"dataframe-centric\"\ndata science called the [\"tidyverse\"](https://www.tidyverse.org).\nThe other tidyverse package we'll cover in today's workshop is _ggplot2_ for making plots.\n\n### Setting up\n\nLet's start a new script for this session:\n\n1. _Open a new R script_ (Click the **`+`** symbol in toolbar at the top, then click `R Script`)^[\n   Or Click `File` => `New file` => `R Script`.].\n   \n2. _Save the script_ straight away as `data-structures.R` --\n   you can save it anywhere you like, though it is probably best to save it in a\n   folder specifically for this workshop.\n   \n3. If you want the section headers as comments in your script,\n   as in the script I am showing you now,\n   then copy-and-paste the following into your script:\n\n<details><summary>Section headers for your script _(Click to expand)_</summary>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1 - Introduction -------------------------------------------------------------\n# 1.3 - Loading the tidyverse\n\n# 1.4 - The gapminder dataset\n\n# 2 - select() to pick columns (variables) -------------------------------------\n\n# 3 - rename() to change column names ------------------------------------------\n\n# 4 - The pipe |> --------------------------------------------------------------\n\n# 5 - filter() to pick rows (observations) -------------------------------------\n\n# Challenge 1\n# Write a single command (which can span multiple lines and include pipes) that\n# will produce a data frame that has lifeExp, country, and year for Africa but not\n# for other continents.\n# How many rows does your data frame have?\n\n# 6 - arrange() to sort data frames --------------------------------------------\n\n# 7 - mutate() to modify values in columns and create new columns --------------\n\n# Challenge 2\n# A: Use mutate() to create a new column called gdp_billion that has the absolute\n#    GDP (i.e., not relative to population size) and does so in units of billions\n#    (i.e., 2.3 would mean 2.3 billion).\n\n# B: (Bonus) Use mutate() to create a new column planet that has the value earth\n#    in every row. We didn’t cover this kind of scenario but go ahead and test \n#    your intuition!\n  \n# 8 - summarize() to compute group-wise summary stats --------------------------\n\n# Challenge 3\n# Calculate the average life expectancy per country. Which has the longest average\n# life expectancy and which has the shortest average life expectancy?\n```\n:::\n\n\n\n\n</details>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Loading the tidyverse\n\nAll core tidyverse packages can be installed and loaded with a single command.\nSince you should already have _installed_ the tidyverse^[\nIf not: run `install.packages(\"tidyverse\")` now.\n], you only need to _load_ it, which you do as follows:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n:::\n\n\n\n\nThe output tells you which packages have been loaded as part of the tidyverse.\n\n::: {.callout-note collapse=\"true\"}\n#### Learn more: Function name \"conflicts\" _(Click to expand)_\nAlso printed above is a \"Conflicts\" section that may seem ominous.\nWhat this means is that two tidyverse functions, `filter()` and `lag()`,\nhave the same names as two functions from the _stats_ package that were already\nin your R environment.\n\n(Those stats package functions are part of what is often referred to as \"base R\":\ncore R functionality that is always available (loaded) when you start R.)\n\nDue to this function name conflict/collision, for example,\nthe `filter()` function from _dplyr_ \"masks\" the `filter()` function from _stats_:\nthat is, if you write a command with `filter()`, it will use the dplyr function\nand not the stats function.\n\nYou _can_ still use a \"masked\" function, but you will need to preface it with its\npackage name as follows: `stats::filter()`.\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### The `gapminder` data set\n\nIn this session and the next one on data visualization,\nwe will work with the `gapminder` data set.\nThis data set is available in a package of the same name\n(while most packages are built around functions so as to extend R's functionality,\nothers merely contain data sets).\n\nThis package, too, you should have already installed^[\nIf not: run `install.packages(\"gapminder\")` now.\n], so you only need to load it right now:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gapminder)\n```\n:::\n\n\n\n\nLet's take a look at the dataset:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n\n\nWe can also use the `View()` function to look at the data frame ---\nthis will open a new tab in our editor pane with a spreadsheet-like look and feel:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nView(gapminder)\n# (Should display the dataset in an editor pane tab)\n```\n:::\n\n\n\n\nThe `gapminder` data frame is a so-called\n**\"tibble\", which is the tidyverse variant of a data frame.**\nThe main difference is the nicer default printing behavior of tibbles:\ne.g. the data types of columns are shown,\nand only a limited number of rows are printed.\n\nAs for the dataset itself, note that each row contains some data\nfor a single country in a specific year\n(across 5-year intervals between 1952 and 2007), with the following columns:\n\n- `country` (stored as a `factor`)\n- `continent` (stored as a `factor`)\n- `year` (stored as an `integer`)\n- `lifeExp` (stored as an `integer`): the **life expectancy** in years\n- `pop` (stored as an `integer`): the **population size**\n- `gdpPercap` (stored as a `double`): the **per-capita GDP**\n\n<br>\n\n## `select()` to pick columns (variables)\n\nTo subset a data frame by keeping or removing certain columns,\nwe can use the `select()` function.\n\nBy default, this function will only **keep the columns that you specify**,\nwhich you typically do simply by listing those columns by name:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(.data = gapminder, year, country, gdpPercap)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 3\n    year country     gdpPercap\n   <int> <fct>           <dbl>\n 1  1952 Afghanistan      779.\n 2  1957 Afghanistan      821.\n 3  1962 Afghanistan      853.\n 4  1967 Afghanistan      836.\n 5  1972 Afghanistan      740.\n 6  1977 Afghanistan      786.\n 7  1982 Afghanistan      978.\n 8  1987 Afghanistan      852.\n 9  1992 Afghanistan      649.\n10  1997 Afghanistan      635.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n\n\nIn the command above, the first argument was the data frame,\nwhereas the other arguments were the (unquoted!) names of columns we wanted to keep.\n\nThe **order of the columns** in the output data frame is exactly as you list them in\n`select()`, and doesn't need to be the same as in the input data frame.\nIn other words, `select()` is also one way to reorder columns.\nIn the example above, we made `year` appear before `country`, for example.\n\nWe can also **specify columns that should be removed**,\nby prefacing their name with a `!` (or a `-`):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(.data = gapminder, !continent)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 5\n   country      year lifeExp      pop gdpPercap\n   <fct>       <int>   <dbl>    <int>     <dbl>\n 1 Afghanistan  1952    28.8  8425333      779.\n 2 Afghanistan  1957    30.3  9240934      821.\n 3 Afghanistan  1962    32.0 10267083      853.\n 4 Afghanistan  1967    34.0 11537966      836.\n 5 Afghanistan  1972    36.1 13079460      740.\n 6 Afghanistan  1977    38.4 14880372      786.\n 7 Afghanistan  1982    39.9 12881816      978.\n 8 Afghanistan  1987    40.8 13867957      852.\n 9 Afghanistan  1992    41.7 16317921      649.\n10 Afghanistan  1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: {.callout-tip appearance='minimal'}\nThere are also ways to e.g. select _ranges_ of columns,\nbut that is beyond the scope of this short workshop.\nCheck the `select()` help by typing `?select` to learn more.\n:::\n\n<br>\n\n## `rename()` to change column names\n\nThe next _dplyr_ function is one of the simplest:\n`rename()` to change column names.\n\nThe syntax to specify the new and old name within the function is `new_name = old_name`\n--- for example, we may want to rename the `gdpPercap` column:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrename(.data = gapminder, gdp_per_capita = gdpPercap)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdp_per_capita\n   <fct>       <fct>     <int>   <dbl>    <int>          <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333           779.\n 2 Afghanistan Asia       1957    30.3  9240934           821.\n 3 Afghanistan Asia       1962    32.0 10267083           853.\n 4 Afghanistan Asia       1967    34.0 11537966           836.\n 5 Afghanistan Asia       1972    36.1 13079460           740.\n 6 Afghanistan Asia       1977    38.4 14880372           786.\n 7 Afghanistan Asia       1982    39.9 12881816           978.\n 8 Afghanistan Asia       1987    40.8 13867957           852.\n 9 Afghanistan Asia       1992    41.7 16317921           649.\n10 Afghanistan Asia       1997    41.8 22227415           635.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n\n\nWe can also rename multiple columns at once:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrename(.data = gapminder, gdp_per_capita = gdpPercap, life_exp = lifeExp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 6\n   country     continent  year life_exp      pop gdp_per_capita\n   <fct>       <fct>     <int>    <dbl>    <int>          <dbl>\n 1 Afghanistan Asia       1952     28.8  8425333           779.\n 2 Afghanistan Asia       1957     30.3  9240934           821.\n 3 Afghanistan Asia       1962     32.0 10267083           853.\n 4 Afghanistan Asia       1967     34.0 11537966           836.\n 5 Afghanistan Asia       1972     36.1 13079460           740.\n 6 Afghanistan Asia       1977     38.4 14880372           786.\n 7 Afghanistan Asia       1982     39.9 12881816           978.\n 8 Afghanistan Asia       1987     40.8 13867957           852.\n 9 Afghanistan Asia       1992     41.7 16317921           649.\n10 Afghanistan Asia       1997     41.8 22227415           635.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n\n\n<br>\n\n## The pipe (`|>`)\n\nSo far, our examples applied a single _dplyr_ function to a data frame,\nand simply printed the output (a new data frame) to screen.\n\nBut in practice, it is common to use several functions in succession to \"wrangle\"\na dataframe into the format we want.\nFor example, if we want to first `select()` one or more columns,\nand then modify the output further by `rename()`-ing a column, we could:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_sel <- select(.data = gapminder, year, country, gdpPercap)\n\nrename(.data = gapminder_sel, gdp_per_capita = gdpPercap)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 3\n    year country     gdp_per_capita\n   <int> <fct>                <dbl>\n 1  1952 Afghanistan           779.\n 2  1957 Afghanistan           821.\n 3  1962 Afghanistan           853.\n 4  1967 Afghanistan           836.\n 5  1972 Afghanistan           740.\n 6  1977 Afghanistan           786.\n 7  1982 Afghanistan           978.\n 8  1987 Afghanistan           852.\n 9  1992 Afghanistan           649.\n10  1997 Afghanistan           635.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n\n\nFor more elaborate editing, we could go on like we did above,\nsuccessively assigning new data frames and moving on to the next step.\n\nBut there is a nicer way of dong this,\nusing so-called \"piping\" with a **pipe operator** (`|>`).\nLet's start by seeing a reformulation of the code above with pipes:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n  select(year, country, gdpPercap) |>\n  rename(gdp_per_capita = gdpPercap)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 3\n    year country     gdp_per_capita\n   <int> <fct>                <dbl>\n 1  1952 Afghanistan           779.\n 2  1957 Afghanistan           821.\n 3  1962 Afghanistan           853.\n 4  1967 Afghanistan           836.\n 5  1972 Afghanistan           740.\n 6  1977 Afghanistan           786.\n 7  1982 Afghanistan           978.\n 8  1987 Afghanistan           852.\n 9  1992 Afghanistan           649.\n10  1997 Afghanistan           635.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n\n\nWhat happened here is that we took the `gapminder` data frame,\npushed (or \"piped\") it into the `select()` function,\nwhose output was in turn piped into the `rename()` function.\n\nYou can think of the pipe as **\"then\"**:\ntake `gapminder`, _then_ select, _then_ rename.\nUsing pipes is slightly less typing and considerably more readable than using\nsuccessive assignments like we did before.^[\nUsing pipes is also faster and uses less computer memory.\n]\n\nWhen using pipes, we no longer specify the input data frame with the `.data`\nargument, because the input is \"already\" being piped into the function\n(by default, the input goes to the function's first argument).\n\n::: {.callout-tip appearance='minimal'}\nFor code readability, it is good practice to always start a new line after a pipe `|>` \n:::\n\n<br>\n\n## `filter()` to pick rows (observations)\n\nThe `filter()` function keeps only those rows that satisfy one or more conditions.\nIt is similar to Filter functionality in spreadsheets ---\nexcept that those only change what you _display_, while `filter()` will _remove_ rows.\nBut if that sounds scary, recall what we mentioned earlier:\n\n> All these functions take a data frame as the _input_,\n> and output a new, modified data frame.\n\n:::{.callout-warning appearance=\"minimal\"}\nTherefore, you would _only_ modify existing data if you would assign the output\nback to the input object, like in the example below with the `select()` function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncats <- cats |> select(name, coat)\n```\n:::\n\n\n\n:::\n\nLet's start with the following example,\nwhere we want to keep observations (remember, these are countries in a given year)\nwith a life expectancy exceeding 80 years:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n  filter(lifeExp > 80)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 21 × 6\n   country          continent  year lifeExp      pop gdpPercap\n   <fct>            <fct>     <int>   <dbl>    <int>     <dbl>\n 1 Australia        Oceania    2002    80.4 19546792    30688.\n 2 Australia        Oceania    2007    81.2 20434176    34435.\n 3 Canada           Americas   2007    80.7 33390141    36319.\n 4 France           Europe     2007    80.7 61083916    30470.\n 5 Hong Kong, China Asia       2002    81.5  6762476    30209.\n 6 Hong Kong, China Asia       2007    82.2  6980412    39725.\n 7 Iceland          Europe     2002    80.5   288030    31163.\n 8 Iceland          Europe     2007    81.8   301931    36181.\n 9 Israel           Asia       2007    80.7  6426679    25523.\n10 Italy            Europe     2002    80.2 57926999    27968.\n# ℹ 11 more rows\n```\n\n\n:::\n:::\n\n\n\n\nSo, we specify a _condition_ based on the values in at least one column\nto only **keep rows satisfying this condition**.\n\nThese conditions don't have to be based on numeric comparisons -- for example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n  filter(continent == \"Europe\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 360 × 6\n   country continent  year lifeExp     pop gdpPercap\n   <fct>   <fct>     <int>   <dbl>   <int>     <dbl>\n 1 Albania Europe     1952    55.2 1282697     1601.\n 2 Albania Europe     1957    59.3 1476505     1942.\n 3 Albania Europe     1962    64.8 1728137     2313.\n 4 Albania Europe     1967    66.2 1984060     2760.\n 5 Albania Europe     1972    67.7 2263554     3313.\n 6 Albania Europe     1977    68.9 2509048     3533.\n 7 Albania Europe     1982    70.4 2780097     3631.\n 8 Albania Europe     1987    72   3075321     3739.\n 9 Albania Europe     1992    71.6 3326498     2497.\n10 Albania Europe     1997    73.0 3428038     3193.\n# ℹ 350 more rows\n```\n\n\n:::\n:::\n\n\n\n\n:::callout-warning\n### Remember to use _two_ equals signs `==` to test for equality!\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n#### Filter based on multiple conditions\n\nIt's also possible to filter based on multiple conditions -- for example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n  filter(continent == \"Asia\", year == 2007, lifeExp > 80)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 6\n  country          continent  year lifeExp       pop gdpPercap\n  <fct>            <fct>     <int>   <dbl>     <int>     <dbl>\n1 Hong Kong, China Asia       2007    82.2   6980412    39725.\n2 Israel           Asia       2007    80.7   6426679    25523.\n3 Japan            Asia       2007    82.6 127467972    31656.\n```\n\n\n:::\n:::\n\n\n\n\nBy default, multiple conditions are combined in an _AND_ fashion ---\nin other words, in a given row, _each_ condition needs to be met for that column\nto be kept.\n\nIf you want to combine conditions in an _OR_ fashion,\nyou should use a `|` as follows:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n  filter(lifeExp > 80 | gdpPercap > 10000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 392 × 6\n   country   continent  year lifeExp      pop gdpPercap\n   <fct>     <fct>     <int>   <dbl>    <int>     <dbl>\n 1 Argentina Americas   1977    68.5 26983828    10079.\n 2 Argentina Americas   1997    73.3 36203463    10967.\n 3 Argentina Americas   2007    75.3 40301927    12779.\n 4 Australia Oceania    1952    69.1  8691212    10040.\n 5 Australia Oceania    1957    70.3  9712569    10950.\n 6 Australia Oceania    1962    70.9 10794968    12217.\n 7 Australia Oceania    1967    71.1 11872264    14526.\n 8 Australia Oceania    1972    71.9 13177000    16789.\n 9 Australia Oceania    1977    73.5 14074100    18334.\n10 Australia Oceania    1982    74.7 15184200    19477.\n# ℹ 382 more rows\n```\n\n\n:::\n:::\n\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n#### Pipeline practice\n\nFinally, let's practice a bit more with \"pipelines\" that use multiple _dplyr_ verbs:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n  filter(continent == \"Americas\") |>\n  select(year, country, gdpPercap) |>\n  rename(gdp_per_capita = gdpPercap)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 300 × 3\n    year country   gdp_per_capita\n   <int> <fct>              <dbl>\n 1  1952 Argentina          5911.\n 2  1957 Argentina          6857.\n 3  1962 Argentina          7133.\n 4  1967 Argentina          8053.\n 5  1972 Argentina          9443.\n 6  1977 Argentina         10079.\n 7  1982 Argentina          8998.\n 8  1987 Argentina          9140.\n 9  1992 Argentina          9308.\n10  1997 Argentina         10967.\n# ℹ 290 more rows\n```\n\n\n:::\n:::\n\n\n\n\n<br>\n\n:::exercise\n### {{< fa user-edit >}} Challenge 1 {-}\n\nWrite a single command (which can span multiple lines and include pipes)\nthat will produce a data frame that has `lifeExp`, `country`, and `year`\nfor Africa but not for other continents. \nHow many rows does your data frame have?\n\n<details><summary>Click for the solution</summary>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n  filter(continent == \"Africa\") |>\n  select(year, country, lifeExp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 624 × 3\n    year country lifeExp\n   <int> <fct>     <dbl>\n 1  1952 Algeria    43.1\n 2  1957 Algeria    45.7\n 3  1962 Algeria    48.3\n 4  1967 Algeria    51.4\n 5  1972 Algeria    54.5\n 6  1977 Algeria    58.0\n 7  1982 Algeria    61.4\n 8  1987 Algeria    65.8\n 9  1992 Algeria    67.7\n10  1997 Algeria    69.2\n# ℹ 614 more rows\n```\n\n\n:::\n:::\n\n\n\n\nIt has 624 rows.\n</details>\n:::\n\n<br>\n\n## `arrange()` to sort data frames\n\nThe `arrange()` function is like sorting functionality in Excel:\nit changes the order of rows based on the values in one or more columns.\n\nFor example, `gapminder` is currently sorted alphabetically by `country`\nand then by `year`, but we may instead want to sort by population size:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n  arrange(pop)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 6\n   country               continent  year lifeExp   pop gdpPercap\n   <fct>                 <fct>     <int>   <dbl> <int>     <dbl>\n 1 Sao Tome and Principe Africa     1952    46.5 60011      880.\n 2 Sao Tome and Principe Africa     1957    48.9 61325      861.\n 3 Djibouti              Africa     1952    34.8 63149     2670.\n 4 Sao Tome and Principe Africa     1962    51.9 65345     1072.\n 5 Sao Tome and Principe Africa     1967    54.4 70787     1385.\n 6 Djibouti              Africa     1957    37.3 71851     2865.\n 7 Sao Tome and Principe Africa     1972    56.5 76595     1533.\n 8 Sao Tome and Principe Africa     1977    58.6 86796     1738.\n 9 Djibouti              Africa     1962    39.7 89898     3021.\n10 Sao Tome and Principe Africa     1982    60.4 98593     1890.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n\n\nSorting can be useful to see the observations with the smallest or largest values\nfor a certain column: above we see that the country and year with the smallest\npopulation size is _Sao Tome and Principe_ in 1952.\n\nDefault sorting is from small to large, but of course,\nwe may also want to sort in the reverse order.\nYou can do this using the `desc()` (descending, large-to-small) helper function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n  arrange(desc(pop))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 6\n   country continent  year lifeExp        pop gdpPercap\n   <fct>   <fct>     <int>   <dbl>      <int>     <dbl>\n 1 China   Asia       2007    73.0 1318683096     4959.\n 2 China   Asia       2002    72.0 1280400000     3119.\n 3 China   Asia       1997    70.4 1230075000     2289.\n 4 China   Asia       1992    68.7 1164970000     1656.\n 5 India   Asia       2007    64.7 1110396331     2452.\n 6 China   Asia       1987    67.3 1084035000     1379.\n 7 India   Asia       2002    62.9 1034172547     1747.\n 8 China   Asia       1982    65.5 1000281000      962.\n 9 India   Asia       1997    61.8  959000000     1459.\n10 China   Asia       1977    64.0  943455000      741.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n\n \nFinally, it is common to want to sort by multiple columns,\nwhere ties in the first column are broken by a second column (and so on) --\nto do so, simply list the columns in the appropriate order:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n  arrange(continent, country)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 6\n   country continent  year lifeExp      pop gdpPercap\n   <fct>   <fct>     <int>   <dbl>    <int>     <dbl>\n 1 Algeria Africa     1952    43.1  9279525     2449.\n 2 Algeria Africa     1957    45.7 10270856     3014.\n 3 Algeria Africa     1962    48.3 11000948     2551.\n 4 Algeria Africa     1967    51.4 12760499     3247.\n 5 Algeria Africa     1972    54.5 14760787     4183.\n 6 Algeria Africa     1977    58.0 17152804     4910.\n 7 Algeria Africa     1982    61.4 20033753     5745.\n 8 Algeria Africa     1987    65.8 23254956     5681.\n 9 Algeria Africa     1992    67.7 26298373     5023.\n10 Algeria Africa     1997    69.2 29072015     4797.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n\n\nThe above example sorts first by continent and _then_ by country.\n\n<br>\n\n## `mutate()` to modify values in columns and create new columns\n\nSo far, we've focused on functions that \"merely\" subset and reorganize data frames.\nWe've also seen how we can modify column names.\nBut we haven't seen how we can _change the data_ or _compute derived data_\nin data frames.\n\nWe can do this with the `mutate()` function.\nFor example, say that we want to create a new column that has population sizes\nin millions rather than in individuals:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n  mutate(pop_million = pop / 10^6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 7\n   country     continent  year lifeExp      pop gdpPercap pop_million\n   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>       <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.        8.43\n 2 Afghanistan Asia       1957    30.3  9240934      821.        9.24\n 3 Afghanistan Asia       1962    32.0 10267083      853.       10.3 \n 4 Afghanistan Asia       1967    34.0 11537966      836.       11.5 \n 5 Afghanistan Asia       1972    36.1 13079460      740.       13.1 \n 6 Afghanistan Asia       1977    38.4 14880372      786.       14.9 \n 7 Afghanistan Asia       1982    39.9 12881816      978.       12.9 \n 8 Afghanistan Asia       1987    40.8 13867957      852.       13.9 \n 9 Afghanistan Asia       1992    41.7 16317921      649.       16.3 \n10 Afghanistan Asia       1997    41.8 22227415      635.       22.2 \n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n\n\nThe code above created a new column called `pop_million` that is the result\nof dividing the values in the `pop` column by a million. \n\nTo modify a column rather than adding a new one,\nsimply \"assign back to the same name\":\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n  mutate(pop = pop / 10^6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp   pop gdpPercap\n   <fct>       <fct>     <int>   <dbl> <dbl>     <dbl>\n 1 Afghanistan Asia       1952    28.8  8.43      779.\n 2 Afghanistan Asia       1957    30.3  9.24      821.\n 3 Afghanistan Asia       1962    32.0 10.3       853.\n 4 Afghanistan Asia       1967    34.0 11.5       836.\n 5 Afghanistan Asia       1972    36.1 13.1       740.\n 6 Afghanistan Asia       1977    38.4 14.9       786.\n 7 Afghanistan Asia       1982    39.9 12.9       978.\n 8 Afghanistan Asia       1987    40.8 13.9       852.\n 9 Afghanistan Asia       1992    41.7 16.3       649.\n10 Afghanistan Asia       1997    41.8 22.2       635.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n\n\n<br>\n\n:::exercise\n### {{< fa user-edit >}} Challenge 2 {-}\n\n**A:** Use `mutate()` to create a new column called `gdp_billion` that has the\n       **absolute** GDP (i.e., not relative to population size) and does so\n       in **units of billions** (i.e., `2.3` would mean 2.3 billion).\n\n<details><summary>Click for the solution</summary>\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n    mutate(gdp_billion = gdpPercap * pop / 10^9)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 7\n   country     continent  year lifeExp      pop gdpPercap gdp_billion\n   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>       <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.        6.57\n 2 Afghanistan Asia       1957    30.3  9240934      821.        7.59\n 3 Afghanistan Asia       1962    32.0 10267083      853.        8.76\n 4 Afghanistan Asia       1967    34.0 11537966      836.        9.65\n 5 Afghanistan Asia       1972    36.1 13079460      740.        9.68\n 6 Afghanistan Asia       1977    38.4 14880372      786.       11.7 \n 7 Afghanistan Asia       1982    39.9 12881816      978.       12.6 \n 8 Afghanistan Asia       1987    40.8 13867957      852.       11.8 \n 9 Afghanistan Asia       1992    41.7 16317921      649.       10.6 \n10 Afghanistan Asia       1997    41.8 22227415      635.       14.1 \n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n\n</details>\n\n**B:** _(Bonus)_ Use `mutate()` to create a new column `planet` that has the value\n`earth` in every row. We didn't cover this kind of scenario, but go ahead and test\nyour intuition!\n\n<details><summary>Click for the solution</summary>\n\nIf you simply provide a value, this will be repeated in every row:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n  mutate(planet = \"earth\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 7\n   country     continent  year lifeExp      pop gdpPercap planet\n   <fct>       <fct>     <int>   <dbl>    <int>     <dbl> <chr> \n 1 Afghanistan Asia       1952    28.8  8425333      779. earth \n 2 Afghanistan Asia       1957    30.3  9240934      821. earth \n 3 Afghanistan Asia       1962    32.0 10267083      853. earth \n 4 Afghanistan Asia       1967    34.0 11537966      836. earth \n 5 Afghanistan Asia       1972    36.1 13079460      740. earth \n 6 Afghanistan Asia       1977    38.4 14880372      786. earth \n 7 Afghanistan Asia       1982    39.9 12881816      978. earth \n 8 Afghanistan Asia       1987    40.8 13867957      852. earth \n 9 Afghanistan Asia       1992    41.7 16317921      649. earth \n10 Afghanistan Asia       1997    41.8 22227415      635. earth \n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n\n</details>\n:::\n\n<br>\n\n## `summarize()` to compute (groupwise) summary stats\n\nIn combination with `group_by()`,\nthe `summarize()` function can compute data summaries across groups of rows of a\ndata frame.\n\nFirst, let's see what `summarize()` does when used by itself:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n  summarize(mean_gdpPercap = mean(gdpPercap),\n            mean_lifeExp = mean(lifeExp))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  mean_gdpPercap mean_lifeExp\n           <dbl>        <dbl>\n1          7215.         59.5\n```\n\n\n:::\n:::\n\n\n\n\nAbove, we computed the mean for two columns, across **all** rows.\nThis is already useful,\nbut in combination with the helper function `group_by()`,\n`summarize()` becomes really powerful by allowing us to compute **groupwise** stats.\n\nFor example, let's compute the mean GDP and mean life expectancy separately\nfor each continent:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n  group_by(continent) |>\n  summarize(mean_gdpPercap = mean(gdpPercap),\n            mean_lifeExp = mean(lifeExp))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  continent mean_gdpPercap mean_lifeExp\n  <fct>              <dbl>        <dbl>\n1 Africa             2194.         48.9\n2 Americas           7136.         64.7\n3 Asia               7902.         60.1\n4 Europe            14469.         71.9\n5 Oceania           18622.         74.3\n```\n\n\n:::\n:::\n\n\n\n\n`group_by()` implicitly splits a data frame into groups of rows:\nhere, one group for observations from each continent.\nAfter that, operations like in `summarize()` will happen separately for each group,\nwhich is how we ended up with per-continent means.\n\nFinally, another powerful feature is that we can _group by multiple variables_ --\nfor example, by `year` _and_ `continent`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n  group_by(continent, year) |>\n  summarize(mean_gdpPercap = mean(gdpPercap),\n            mean_lifeExp = mean(lifeExp))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'continent'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 4\n# Groups:   continent [5]\n   continent  year mean_gdpPercap mean_lifeExp\n   <fct>     <int>          <dbl>        <dbl>\n 1 Africa     1952          1253.         39.1\n 2 Africa     1957          1385.         41.3\n 3 Africa     1962          1598.         43.3\n 4 Africa     1967          2050.         45.3\n 5 Africa     1972          2340.         47.5\n 6 Africa     1977          2586.         49.6\n 7 Africa     1982          2482.         51.6\n 8 Africa     1987          2283.         53.3\n 9 Africa     1992          2282.         53.6\n10 Africa     1997          2379.         53.6\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n<br>\n\n:::exercise\n### {{< fa user-edit >}} Challenge 3 {-}\n\nCalculate the average life expectancy per country.\nWhich has the longest average life expectancy and which has the shortest\naverage life expectancy?\n\n<details><summary>Click for the solution</summary>\n\nFirst, let's create a dataframe with the mean life expectancy by country:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlifeExp_bycountry <- gapminder |>\n   group_by(country) |>\n   summarize(mean_lifeExp = mean(lifeExp))\n```\n:::\n\n\n\n\nThen, arrange that dataframe in two directions to see the countries with the\nlongest and shortest life expectance --\npiping into `head()` as a bonus to only see the top n, here top 1:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlifeExp_bycountry |>\n   arrange(mean_lifeExp) |>\n   head(n = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  country      mean_lifeExp\n  <fct>               <dbl>\n1 Sierra Leone         36.8\n```\n\n\n:::\n\n```{.r .cell-code}\nlifeExp_bycountry |>\n   arrange(desc(mean_lifeExp)) |>\n   head(n = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  country mean_lifeExp\n  <fct>          <dbl>\n1 Iceland         76.5\n```\n\n\n:::\n:::\n\n\n\n</details>\n:::\n\n<br>\n\n------\n\n------\n\n<br>\n\n## Bonus material for self-study\n\n### Writing and reading tabular data to and from files\n\nWhen working with your own data in R,\nit is common to want to read data from files into your R environment,\nand write data that is in your R environment to files.\n\nWhile it's possible to have R interact with Excel spreadsheet files^[\nUsing the [readxl](https://readxl.tidyverse.org/) package.\nThis is installed as part of the tidyverse but is not a _core_ tidyverse package\nand therefore needs to be loaded separately.\n], keeping your data in **plain-text files** generally benefits reproducibility.\nTabular plain text files can be stored using:\n\n- A _Tab_ as the column delimiter\n  (often called TSV files, and stored with a `.tsv` extension)\n- A _comma_ as the column delimiter\n  (often called CSV files, and stored with a `.csv` extension).\n\nWe will use functions from the _readr_ package,\nwhich is part of the core tidyverse and therefore already loaded into your environment,\nto practice writing and reading data to and from TSV files.\n\n#### Writing files\n\nFirst, let's write the `gapminder` data frame to file using the `write_tsv()`\nfunction with arguments `x` for the R object and `file` for the file path:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_tsv(x = gapminder, file = \"gapminder.tsv\")\n```\n:::\n\n\n\n\nThis will have written to a file called `gapminder.tsv` in your R working directory\n(you can see where that is at the top of the Console, or by running `getwd()`).\n\n::: callout-tip\n### Checking out the file\n\nIn RStudio's **Files pane**,\nfind your new file and click on it.\nThat way, the file will open in the editor.\n:::\n\n::: {.callout-note collapse=\"true\"}\n### Want to write to a different folder on your computer? _(Click to expand)_\n\nThe `file` argument to `write_tsv()` takes a file _path_,\nmeaning that you can specify any location on your computer for it it in addition\nto its name.\n\nFor example, if you had a folder called `results` in your current working directory\n(directory is just another word for folder), you could put the file in there:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_tsv(x = gapminder, file = \"results/gapminder.tsv\")\n```\n:::\n\n\n\n\nNote that a forward slash `/` as a folder delimiter will work regardless of your\noperating system\n(even though Windows natively delimits folder by a backslash `\\`).\n\nFinally, if you want to store the file in a totally different place than where\nyou are now, note that you can also use so-called absolute (or \"full\") paths like:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_tsv(x = gapminder, file = \"/Users/poelstra.1/Desktop/gapminder.tsv\")\n```\n:::\n\n\n\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n#### Reading from files\n\nTo practice reading data from a file,\nwe'll use the `read_tsv()` function on the file we just created: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_reread <- read_tsv(file = \"gapminder.tsv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 1704 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (2): country, continent\ndbl (4): year, lifeExp, pop, gdpPercap\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\n\n\nNote that the function is rather chatty by default,\ntelling us how many rows and columns it read in, and what their data types are.\nLet's check the resulting object:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_reread\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   <chr>       <chr>     <dbl>   <dbl>    <dbl>     <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n\n\nThis looks good!\nDo note that the column's data types are not identical to what they were\n(`year` and `pop` are saved as `double` rather than `integer`,\nand `country` and `continent` as `character` rather than `factor`).\nThis is largely expected because that kind of metadata is not stored in a plain-text\nTSV, so `read_tsv()` will by default simply make best guesses as to the types.\n\nAlternatively, we could tell read_tsv what the column types should be using\nabbreviations (`f` for `factor`, `i` for `integer`, `d` for `double` ---\nrun `?read_tsv` for more info):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_tsv(file = \"gapminder.tsv\", col_types = \"ffidi\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-tip appearance='minimal'}\nTo read and write CSV files instead, use `read_csv()` / `write_csv()` in the same way.\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### `count()` and `n()`\n\nA common operation is to count the number of observations for each group.\nThe _dplyr_ package comes with two related functions that help with this.\n\nFor instance, if we wanted to check the number of countries included in the\ndataset for the year 2002, we can use the `count()` function.\nIt takes the name of one or more columns that contain the groups we are interested in,\nand we can optionally sort the results in descending order by adding `sort = TRUE`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n    filter(year == 2002) |>\n    count(continent, sort = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n  continent     n\n  <fct>     <int>\n1 Africa       52\n2 Asia         33\n3 Europe       30\n4 Americas     25\n5 Oceania       2\n```\n\n\n:::\n:::\n\n\n\n\nIf we need to use the number of observations in calculations like by `summarize()`,\nthe `n()` function is useful.\nIt will return the total number of observations in the \"_current group_\"\nas applicable ---\nfor instance,\nif we wanted to get the standard error of the life expectancy per continent:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n  group_by(continent) |>\n  summarize(se_life = sd(lifeExp) / sqrt(n()))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n  continent se_life\n  <fct>       <dbl>\n1 Africa      0.366\n2 Americas    0.540\n3 Asia        0.596\n4 Europe      0.286\n5 Oceania     0.775\n```\n\n\n:::\n:::\n\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Learn more\n\nThis material was adapted from\n[this Carpentries lesson episode](https://swcarpentry.github.io/r-novice-gapminder/instructor/12-dplyr.html).\n\nIn your journey to become a skilled data frame wrangler in R,\nhere are some additional topics that are very useful but beyond the scope of this\nworkshop:\n\n- Joining/merging -- combining multiple dataframes based on one or more shared\n  columns. This can be done with _dplyr_'s `join_*()` functions.\n\n- Pivoting/reshaping -- moving between 'wide' and 'long' data formats\n  with `pivot_wider()` and `pivot_longer()` -- this is covered in\n  [episode 13 of our focal Carpentries lesson](https://swcarpentry.github.io/r-novice-gapminder/instructor/13-tidyr.html).\n\n<br>\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}