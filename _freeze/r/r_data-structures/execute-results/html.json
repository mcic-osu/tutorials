{
  "hash": "67dbb56c3ce7f7595cf1a3d52f668039",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R's data structures and data types\"\nauthor: \"Software Carpentry / Jelmer Poelstra\"\ndate: 2025-02-11\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n-----\n\n<br>\n\n## Introduction\n\n#### What we'll cover\n\nIn this session, we will learn about R's **data structures** and **data types**.\n\n- **Data structures** are the kinds of objects that R can store data in.\n  Here, we will cover the two most common ones: _vectors_ and _data frames_.\n\n- **Data types** are how R distinguishes between different kinds of data like numbers\n  and character strings.\n  Here, we'll talk about the 4 main data types:\n  `character`, `integer`, `double`, and `logical.`\n  We'll also cover `factor`s, a construct related to the data types.\n\n#### Setting up\n\nTo make it easier to keep track of what we do,\nwe'll write our code in a script (and send it to the console from there) --\nhere is how to create and save a new R script:\n\n1. _Open a new R script_ (Click the **`+`** symbol in toolbar at the top, then click `R Script`)^[\n   Or Click `File` => `New file` => `R Script`.].\n   \n2. _Save the script_ straight away as `data-structures.R` --\n   you can save it anywhere you like, though it is probably best to save it in a\n   folder specifically for this workshop.\n   \n3. If you want the section headers as comments in your script,\n   as in the script I am showing you now,\n   then copy-and-paste the following into your script:\n\n<details><summary>Section headers for your script _(Click to expand)_</summary>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 2 - Vectors ------------------------------------------------------------------\n# 2.1 - Single-element vectors and quoting\n\n# 2.2 - Multi-element vectors\n\n# 2.3 - Vectorization\n\n# Challenge 1\n# A. Start by making a vector x with the whole numbers 1 through 26.\n#    Then, subtract 0.5 from each element in the vector and save the result in vector y.\n#    Check your results by printing both vectors.\n\n# B. What do you think will be the result of the following operation?\n#    1:5 * 1:5\n\n# 2.4 - Exploring vectors\n\n# 2.5 - Extracting element from vectors\n\n# 3 - Data frames --------------------------------------------------------------\n# 3.1 - Data frame intro\n\n# 4 - Data types ---------------------------------------------------------------\n# 4.1 - R's main data types\n\n# 4.2 - Factors\n\n# 4.3 - A vector can only contain one data type\n\n# Challenge 2\n# What type of vector (if any) do you think each of the following will produce?\n# Try it out and see if you were right.\n#   typeof(\"TRUE\")\n#   typeof(banana)\n#   typeof(c(2, 6, \"3\"))\n# Bonus / trick question:\n#   typeof(18, 3)\n\n# 4.4 - Automatic type coercion\n# 4.5 - Manual type conversion\n```\n:::\n\n\n\n</details>\n\n<br>\n\n## Data structure 1: Vectors\n\nThe first data structure we will explore is the simplest: the vector.\nA vector in R is essentially **a collection of one or more items**.\nMoving forward, we'll call such individual items \"elements\".\n\n### Single-element vectors and quoting\n\nVectors can consist of just a single element,\nso each of the two lines of code below creates a vector:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvector1 <- 8\nvector2 <- \"panda\"\n```\n:::\n\n\n\n\nTwo things are worth noting about the `\"panda\"` example,\nwhich is a so-called **character string** (or _string_ for short):\n\n- `\"panda\"` constitutes _one element_, not 5 (its number of letters).\n- Unlike when dealing with numbers, we have to _quote the string_.^[\n  Either double quotes (`\"...\"`) or single quotes (`'...'`) work,\n  but the former are most commonly used by convention.]\n\nCharacter strings need to be quoted because they are otherwise interpreted as\nR objects -- for example, because our vectors `vector1` and `vector2` are objects,\nwe refer to them without quotes:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# [Note that R will show auto-complete options after you type 3 characters]\nvector1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n\n```{.r .cell-code}\nvector2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"panda\"\n```\n\n\n:::\n:::\n\n\n\n\nTherefore, the code below doesn't work, because there is no _object called `panda`_:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvector_fail <- panda\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: object 'panda' not found\n```\n\n\n:::\n:::\n\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Multi-element vectors\n\nA common way to make vectors with **multiple elements** is\nby using the `c` (combine) function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(2, 6, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 6 3\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-note appearance='minimal'}\n_Unlike in the first couple of vector examples,_\n_we didn't save the above vector to an object:_\n_now the vector simply printed to the console -- but it is created all the same._\n:::\n\n`c()` can also **append** elements to an existing vector:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# First we create a vector:\nvector_to_append <- c(\"vhagar\", \"meleys\")\nvector_to_append\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"vhagar\" \"meleys\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Then we append another element to it:\nc(vector_to_append, \"balerion the dread\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"vhagar\"             \"meleys\"             \"balerion the dread\"\n```\n\n\n:::\n:::\n\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nTo create vectors with **series of numbers**, a couple of shortcuts are available.\nFirst, you can make series of whole numbers with the `:` operator:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n:::\n\n\n\n\nSecond, you can use a function like `seq()` for fine control over the sequence: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyseq <- seq(from = 6, to = 8, by = 0.2)\nmyseq\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 6.0 6.2 6.4 6.6 6.8 7.0 7.2 7.4 7.6 7.8 8.0\n```\n\n\n:::\n:::\n\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Vectorization\n\nConsider the output of this command:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyseq * 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 12.0 12.4 12.8 13.2 13.6 14.0 14.4 14.8 15.2 15.6 16.0\n```\n\n\n:::\n:::\n\n\n\n\nAbove, **every individual element in `myseq` was multiplied by 2**.\nWe call this behavior \"vectorization\" and this is a key feature of the R language.\n(Alternatively, you may have expected this code to _repeat_ `myseq` twice,\nbut this did not happen!)\n\n::: {.callout-note appearance='minimal'}\nFor more about vectorization, see\n[episode 9](https://swcarpentry.github.io/r-novice-gapminder/instructor/09-vectorization.html)\nfrom the Carpentries lesson that this material is based on.\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: exercise\n### {{< fa user-edit >}} Challenge 1 {-}\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n**A.**\nStart by making a vector `x` with the whole numbers 1 through 26.\nThen, subtract 0.5 from each element in the vector and save the result in vector `y`.\nCheck your results by printing both vectors.\n\n<details><summary>Click for the solution</summary>\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:26\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26\n```\n\n\n:::\n\n```{.r .cell-code}\ny <- x - 0.5\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  0.5  1.5  2.5  3.5  4.5  5.5  6.5  7.5  8.5  9.5 10.5 11.5 12.5 13.5 14.5\n[16] 15.5 16.5 17.5 18.5 19.5 20.5 21.5 22.5 23.5 24.5 25.5\n```\n\n\n:::\n:::\n\n\n\n\n</details>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n**B.** \nWhat do you think will be the result of the following operation?\nTry it out and see if you were right.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:5 * 1:5\n```\n:::\n\n\n\n\n<details><summary>Click for the solution</summary>\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:5 * 1:5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  4  9 16 25\n```\n\n\n:::\n:::\n\n\n\n\nBoth vectors are of length 5 which will lead to \"element-wise matching\":\nthe first element in the first vector will be multiplied with the first element\nin the second vector,\nthe second element in the first vector will be multiplied with the second element\nin the second vector, and so on.\n\n</details>\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Exploring vectors\n\nR has many built-in functions to get information about vectors and other types of\nobjects, such as:\n\nGet the **first and last few elements**, respectively, with `head()` and `tail()`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Print the first 6 elements:\nhead(myseq)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6.0 6.2 6.4 6.6 6.8 7.0\n```\n\n\n:::\n\n```{.r .cell-code}\n# Both head and tail take an argument `n` to specify the number of elements to print:\nhead(myseq, n = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6.0 6.2\n```\n\n\n:::\n\n```{.r .cell-code}\n# Print the last 6 elements:\ntail(myseq)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7.0 7.2 7.4 7.6 7.8 8.0\n```\n\n\n:::\n:::\n\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nGet the **number of elements** with `length()`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(myseq)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n:::\n\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nGet **arithmetic summaries** like `sum()` and `mean()` for vectors with numbers:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# sum() will sum the values of all elements\nsum(myseq)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 77\n```\n\n\n:::\n\n```{.r .cell-code}\n# mean() will compute the mean (average) across all elements\nmean(myseq)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n:::\n\n\n\n\n<br>\n\n### Extracting elements from vectors\n\nExtracting element from objects like vectors is often referred to as **\"indexing\"**.\nIn R, we can do this using bracket notation -- for example:\n\n- Get the second element:\n\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  myseq[2]\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  [1] 6.2\n  ```\n  \n  \n  :::\n  :::\n\n\n\n\n- Get the second through the fifth elements:\n\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  myseq[2:5]\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  [1] 6.2 6.4 6.6 6.8\n  ```\n  \n  \n  :::\n  :::\n\n\n\n\n- Get the first and eight elements:\n\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  myseq[c(1, 8)]\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  [1] 6.0 7.4\n  ```\n  \n  \n  :::\n  :::\n\n\n\n\nTo put this in a general way:\nwe can extract elements from a vector by using another vector,\nwhose values are the positional indices of the elements in the original vector.\n\n<br>\n\n## Data structure 2: Data frames\n\n### R stores tabular data in \"data frames\"\n\nOne of R's most powerful features is its **built-in ability to deal with tabular data** --\ni.e., data with rows and columns like you are familiar with from spreadsheets\nlike those you create with Excel.\n\nIn R, tabular data is stored in objects that are called \"**data frames**\",\nthe second R data structure we'll cover in some depth.\nLet's start by making a toy data frame with information about 3 cats:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncats <- data.frame(\n  name = c(\"Luna\", \"Thomas\", \"Daisy\"),\n  coat = c(\"calico\", \"black\", \"tabby\"),\n  weight = c(2.1, 5.0, 3.2)\n  )\n\ncats\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    name   coat weight\n1   Luna calico    2.1\n2 Thomas  black    5.0\n3  Daisy  tabby    3.2\n```\n\n\n:::\n:::\n\n\n\n\nAbove:\n\n- We created 3 vectors and pasted them side-by-side to create a data frame\n  in which _each vector constitutes a column_.\n- We gave each vector a name (e.g., `coat`), and those names became the _column names_.\n- The resulting data frame has 3 rows (one for each cat) and 3 columns\n  (each with a type of info about the cats, like coat color).\n\nData frames are typically (and best) organized like above, where:\n\n- Each column contains a different **\"variable\"** (e.g. coat color, weight)\n- Each row contains a different **\"observation\"** (data on e.g. one cat/person/sample)\n\nThat's all we'll say about data frames for now,\nbut in today's remaining sessions we will explore this key R data structure more!\n\n<br>\n\n## Data types\n\n### R's main Data Types\n\nR distinguishes different kinds of data, such as character strings and numbers,\nin a formal way, using several pre-defined \"data types\".\nThe behavior of R in various operations will depend heavily on the data type --\nfor example, the below fails:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"valerion\" * 5\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in \"valerion\" * 5: non-numeric argument to binary operator\n```\n\n\n:::\n:::\n\n\n\n\nWe can ask what type of data something is in R using the `typeof()` function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(\"valerion\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\nR sets the data type of `\"valerion\"` to `character`,\nwhich we commonly refer to as character strings or strings.\nIn formal terms, the failed command did not work because R will not allow us to\nperform mathematical functions on vectors of type `character`.\n\nThe `character` data type most commonly contains letters,\nbut anything that is placed between quotes (`\"...\"`) will be interpreted as the\n`character` data type --- even plain numbers:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(\"5\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nBesides `character`, the other 3 **common data types** are:\n\n- `double` / `numeric` -- numbers that can have decimal points:\n\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  typeof(3.14)\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  [1] \"double\"\n  ```\n  \n  \n  :::\n  :::\n\n\n\n\n- `integer` -- whole numbers only:\n\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  typeof(1:3)\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  [1] \"integer\"\n  ```\n  \n  \n  :::\n  :::\n\n\n\n\n- `logical` (either `TRUE` or `FALSE` -- unquoted!):\n\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  typeof(TRUE)\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  [1] \"logical\"\n  ```\n  \n  \n  :::\n  :::\n\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Factors\n\n**Categorical** data, like treatments in an experiment,\ncan be stored as \"factors\" in R.\nFactors are useful for statistical analyses and for plotting,\ne.g. because they allow you to specify a custom order.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiet_vec <- c(\"high\", \"medium\", \"low\", \"low\", \"medium\")\ndiet_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"high\"   \"medium\" \"low\"    \"low\"    \"medium\"\n```\n\n\n:::\n\n```{.r .cell-code}\nfactor(diet_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] high   medium low    low    medium\nLevels: high low medium\n```\n\n\n:::\n:::\n\n\n\n\nIn the example above, we turned a character vector into a factor.\nIts \"levels\" (low, medium, high) are sorted alphabetically by default,\nbut we can manually specify an order that makes more sense:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiet_fct <- factor(diet_vec, levels = c(\"low\", \"medium\", \"high\"))\ndiet_fct\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] high   medium low    low    medium\nLevels: low medium high\n```\n\n\n:::\n:::\n\n\n\n\nThis ordering would be automatically respected in plots and statistical analyses.\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: {.callout-warning collapse='true'}\n### Oddly, factors are technically not a data type _(Click to expand)_\nFor most intents and purposes,\nit makes sense to think of factors as another data type, even though technically,\nthey are a kind of data structure build on the `integer` data type:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(diet_fct)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### A vector can only contain one data type \n\nIndividual vectors, and therefore also individual columns in data frames,\ncan only **be composed of a single data type**.\n\nR will silently pick the \"best-fitting\" data type when you enter or read data into\na data frame.\nSo let's see what the data types are in our `cats` data frame:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(cats)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t3 obs. of  3 variables:\n $ name  : chr  \"Luna\" \"Thomas\" \"Daisy\"\n $ coat  : chr  \"calico\" \"black\" \"tabby\"\n $ weight: num  2.1 5 3.2\n```\n\n\n:::\n:::\n\n\n\n\n- The `name` and `coat` columns are `character`, abbreviated `chr`.\n- The `weight` column is `double`/`numeric`, abbreviated `num`.\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: exercise\n### {{< fa user-edit >}} Challenge 2 {-}\n\nWhat type of vector (if any) do you think each of the following will produce?\nTry it out and see if you were right.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(\"TRUE\")\ntypeof(banana)\ntypeof(c(2, 6, \"3\"))\n```\n:::\n\n\n\n\nBonus / trick question:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(18, 3)\n```\n:::\n\n\n\n\n<details><summary>Click for the solutions</summary>\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(\"TRUE\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n1. `\"TRUE\"` is `character` (and not `logical`) because of the quotes around it.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(banana)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: object 'banana' not found\n```\n\n\n:::\n:::\n\n\n\n\n2. Recall the earlier example:\n   this returns an error because the object `banana` does not exist.\n   Any unquoted string (that is not a special keyword like `TRUE` and `FALSE`)\n   is interpreted as a reference to an object in R.\n   \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(c(2, 6, \"3\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n3. We'll talk about why this produces a `character` vector in the next section.\n   \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(18, 3)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in typeof(18, 3): unused argument (3)\n```\n\n\n:::\n:::\n\n\n\n\n4. This produces an error because the `typeof()` only accepts a single argument,\n   which is an R object like a vector.\n   Because we did not wrap `18, 3` within `c()` (i.e. we did not use `c(18, 3)`),\n   we ended up passing **two** arguments to the function, and this resulted in\n   an error.\n   \n   If you guessed that it would have TWICE returned `integer` (or `double`),\n   you were on the right track: you couldn't have known that the function does\n   not accept multiple objects.\n   \n</details>\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Automatic Type Coercion\n\nThat a character vector was returned by `c(2, 6, \"3\")` in the challenge above\nis due to something called **type coercion**.\n\nWhen R encounters a _mix of types_ (here, numbers and characters)\nto be combined into a single vector, it will force them all to be the same type.\nIt \"must\" do this because, as pointed out above,\na vector can consist of only a single data type.\n\nType coercion can be the source of many surprises,\nand is one reason we need to be aware of the basic data types and how R will\ninterpret them.\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Manual Type Conversion\n\nLuckily, you are not simply at the mercy of whatever R decides to do automatically,\nbut can convert vectors at will using the `as.` group of functions:\n\n:::callout-tip\n### Try to use RStudio's auto-complete functionality here: type \"`as.`\" and then press the <kbd>Tab</kbd> key.\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.integer(c(\"0\", \"2\", \"4\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 2 4\n```\n\n\n:::\n\n```{.r .cell-code}\nas.character(c(0, 2, 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0\" \"2\" \"4\"\n```\n\n\n:::\n:::\n\n\n\n\nAs you may have guessed, though, not all type conversions are possible ---\nfor example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.double(\"kiwi\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: NAs introduced by coercion\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n\n\n(`NA` is R's way of denoting _missing data_ --\nsee [this bonus section](#missing-values-na) for more.)\n\n<br>\n\n------\n\n------\n\n<br>\n\n## Bonus material for self-study\n\n### Changing vector elements using indexing\n\nAbove, we saw how we can _extract_ elements of a vector using indexing.\nTo _change_ elements in a vector,\nsimply use the bracket on the other side of the arrow -- for example:\n\n- Change the first element to `30`:\n\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  myseq[1] <- 30\n  myseq\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n   [1] 30.0  6.2  6.4  6.6  6.8  7.0  7.2  7.4  7.6  7.8  8.0\n  ```\n  \n  \n  :::\n  :::\n\n\n\n\n- Change the last element to `0`:\n\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  myseq[length(myseq)] <- 0\n  myseq\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n   [1] 30.0  6.2  6.4  6.6  6.8  7.0  7.2  7.4  7.6  7.8  0.0\n  ```\n  \n  \n  :::\n  :::\n\n\n\n  \n- Change the second element to the mean value of the vector:\n\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  myseq[2] <- mean(myseq)\n  myseq\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n   [1] 30.000000  8.454545  6.400000  6.600000  6.800000  7.000000  7.200000\n   [8]  7.400000  7.600000  7.800000  0.000000\n  ```\n  \n  \n  :::\n  :::\n\n\n\n  \n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Extracting columns from a data frame\n\nWe can extract individual columns from a data frame using the `$` operator:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncats$weight\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.1 5.0 3.2\n```\n\n\n:::\n\n```{.r .cell-code}\ncats$coat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"calico\" \"black\"  \"tabby\" \n```\n\n\n:::\n:::\n\n\n\n\nThis kind of operation will return a vector -- and can be indexed as well:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncats$weight[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### More on the `logical` data type\n\nLet's add a column to our `cats` data frame indicating whether each cat does\nor does not like string:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncats$likes_string <- c(1, 0, 1)\ncats\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    name   coat weight likes_string\n1   Luna calico    2.1            1\n2 Thomas  black    5.0            0\n3  Daisy  tabby    3.2            1\n```\n\n\n:::\n:::\n\n\n\n\nSo, `likes_string` is numeric,\nbut the `1`s and `0`s actually represent `TRUE` and `FALSE`.\n\nWe could instead use the `logical` data type here,\nby converting this column with the `as.logical()` function,\nwhich will turn 0's into `FALSE` and everything else, including 1, to `TRUE`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.logical(cats$likes_string)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n\n\nAnd to actually modify this column in the dataframe itself, we would do this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncats$likes_string <- as.logical(cats$likes_string)\ncats\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    name   coat weight likes_string\n1   Luna calico    2.1         TRUE\n2 Thomas  black    5.0        FALSE\n3  Daisy  tabby    3.2         TRUE\n```\n\n\n:::\n:::\n\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nYou might think that `1`/`0` could be a handier coding than `TRUE`/`FALSE`\nbecause it may make it easier, for exmaple,\nto count the number of times something is true or false.\nBut consider the following:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE + TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\nSo, logicals can be used as if they were numbers,\nin which case `FALSE` represents 0 and `TRUE` represents 1.\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Missing values (`NA`)\n\nR has a concept of missing data, which is important in statistical computing,\nas not all information/measurements are always available for each sample.\n\nIn R, missing values are coded as `NA`\n(and like `TRUE`/`FALSE`, this is not a character string, so it is not quoted):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This vector will contain one missing value\nvector_NA <- c(1, 3, NA, 7)\nvector_NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  3 NA  7\n```\n\n\n:::\n:::\n\n\n\n\nA key thing to be aware of with `NA`s is that many functions that operate on vectors\nwill return `NA` if **any** element in the vector is `NA`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(vector_NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n\n\nThe way to get around this is by setting `na.rm = TRUE` in such functions,\nfor example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(vector_NA, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n:::\n\n\n\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### A few other data structures in R\n\nWe did not go into details about R's other data structures,\nwhich are less common than vectors and data frames.\nTwo that are worth mentioning briefly, though, are:\n\n- **Matrix**, which can be convenient when you have tabular data that is exclusively\n  numeric (excluding names/labels).\n\n- **List**, which is more flexible (and complicated) than vectors:\n  it can contain multiple data types, and can also be hierarchically structured.\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: exercise\n### {{< fa user-edit >}} Bonus Challenge {-}\n\nAn important part of every data analysis is cleaning input data.\nHere, you will clean a cat data set that has an added observation with a\nproblematic data entry.\n\nStart by creating the new data frame:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncats_v2 <- data.frame(\n  name = c(\"Luna\", \"Thomas\", \"Daisy\", \"Oliver\"),\n  coat = c(\"calico\", \"black\", \"tabby\", \"tabby\"),\n  weight = c(2.1, 5.0, 3.2, \"2.3 or 2.4\")\n)\n```\n:::\n\n\n\n\nThen move on to the tasks below,\nfilling in the blanks (`_____`) and running the code:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Explore the data frame,\n#    including with an overview that shows the columns' data types:\ncats_v2\n_____(cats_v2)\n\n# 2. The \"weight\" column has the incorrect data type _____.\n#    The correct data type is: _____.\n\n# 3. Correct the 4th weight with the mean of the two given values,\n#    then print the data frame to see the effect:\ncats_v2$weight[4] <- 2.35\ncats_v2\n\n# 4. Convert the weight column to the right data type:\ncats_v2$weight <- _____(cats_v2$weight)\n\n# 5. Calculate the mean weight of the cats:\n_____\n```\n:::\n\n\n\n\n<details><summary>Click for the solution</summary>\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Explore the data frame,\n#    including with an overview that shows the columns' data types:\ncats_v2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    name   coat     weight\n1   Luna calico        2.1\n2 Thomas  black          5\n3  Daisy  tabby        3.2\n4 Oliver  tabby 2.3 or 2.4\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(cats_v2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t4 obs. of  3 variables:\n $ name  : chr  \"Luna\" \"Thomas\" \"Daisy\" \"Oliver\"\n $ coat  : chr  \"calico\" \"black\" \"tabby\" \"tabby\"\n $ weight: chr  \"2.1\" \"5\" \"3.2\" \"2.3 or 2.4\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# 2. The \"weight\" column has the incorrect data type CHARACTER.\n#    The correct data type is: DOUBLE.\n\n# 3. Correct the 4th weight data point with the mean of the two given values,\n#    then print the data frame to see the effect:\ncats_v2$weight[4] <- 2.35\ncats_v2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    name   coat weight\n1   Luna calico    2.1\n2 Thomas  black      5\n3  Daisy  tabby    3.2\n4 Oliver  tabby   2.35\n```\n\n\n:::\n\n```{.r .cell-code}\n# 4. Convert the weight column to the right data type:\ncats_v2$weight <- as.double(cats_v2$weight)\n\n# 5. Calculate the mean weight of the cats:\nmean(cats_v2$weight)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.1625\n```\n\n\n:::\n:::\n\n\n\n\n</details>\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Learn more\n\nTo learn more about data types and data structures, see\n[this episode from a separate Carpentries lesson](https://swcarpentry.github.io/r-novice-inflammation/13-supp-data-structures.html).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}