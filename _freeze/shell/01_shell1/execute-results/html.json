{
  "hash": "256bcb30609fa56f69ca91e286350623",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Intro to the Unix Shell\"\npagetitle: \"Shell Basics\"\nauthor: Jelmer Poelstra\ndate: 2024-08-29\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n--------------------------------------------------------------------------------\n\n<br>\n\n## Goals for this session\n\nIn this session, we'll learn:\n\n- Why using a command-line interface can be beneficial.\n- What the Unix shell is and what you can do with it. \n- Using the shell, learn how to:\n  - Navigate around your computer.\n  - Create and manage directories and files.\n  - View text files.\n  - Search within, manipulate, and extract information from text files.\n\n<br>\n\n## Introduction (Ch. 1.1-1.2)\n\n### Some terminology\n\n#### Unix (vs. Linux)\n\nWe can conceptualize Unix (or \"Unix-like\" / \"*nix\")^[\n_Technically_, the latter terms are more correct, as Unix formally does refer to a specific operating system.]\nas a **family of operating systems**, which includes Linux and Mac but not Windows.\n\n#### Unix shell-related terms\n\n-   **Command Line** — the most general term, an interface[^1] where you type commands\n-   **Terminal** — the program/app/window that can run a Unix shell\n-   **Shell** — a command line interface to your computer\n-   **Unix Shell** — the types of shells on Unix family (Linux + Mac) computers\n-   **Bash** — the specific Unix shell language that is most common on Unix computers\n\n[^1]: Command-line Interface (CLI), as opposed to Graphical User Interface (GUI)\n\nWhile these are not synonyms, in day-to-day computing/bioinformatics,\nthey are often used interchangeably.\n\n### Why use the Unix shell?\n\n-   Versus programs with graphical user interfaces:\n\n    -   **Using software**\\\n        Best or only option to use many programs, especially in bioinformatics.\n    -   **Automation and fewer errors**\\\n        The shell allows you to repeat and automate tasks easily and without\n        introducing errors.\n    -   **Reproducibility**\\\n        The shell keeps a record of what you have done.\n    -   **Working with large files**\\\n        Shell commands are good at processing large files, which are common when\n        working with omics data\n    -   **Remote computing – especially HPCs**\\\n        It is often only possible to work in a terminal when doing remote computing.\n\n-   Versus scripting languages like Python or R:\n\n    -   For many simpler tasks, built-in shell tools are faster --- in terms of\n        coding time, processing time, and the ease of processing very large\n        files.\n    -   The Unix shell has a *direct* interface to other programs.\n\n<br>\n\n## Getting started with Unix (Ch. 1.3)\n\n#### Unix directory structure\n\n-   \"Directory\" (or \"**dir**\" for short) is the term for *folder* that is commonly used in Unix contexts.\n    \n-   The Unix directory structure is hierarchical, with a single starting point:\n    the **root**, depicted as **`/`**.\n\n-   A \"**path**\" gives the location of a file or directory, in which directories\n    are separated by forward slashes `/`.\n    \n-   For example, the path to our OSC project's dir is `/fs/ess/PAS2700`.\n    This means: the dir `PAS2700` is located inside the dir `ess`, which in turn is\n    inside the dir `fs`, which in turn is in the computer's root directory.\n\n-   The OSC dir structure is somewhat different from that of a personal computer.\n    Our Home dir is not `/home/<username>` like in the book and the schematic\n    on the left, but `/users/<a-project>/<username>`.\n\n::: columns\n::: column\n![Generic example, from [O'Neil 2017](https://open.oregonstate.education/computationalbiology/chapter/the-command-line-and-filesystem/)](img/oneil_filesystem_ex2.png){fig-align=\"center\" width=\"95%\"}\n:::\n::: column\n![Key dirs in OSC dir structure](img/osc_dirstructure.png){fig-align=\"center\" width=\"89%\"}\n:::\n:::\n\n<br>\n\n## Getting started with the shell (Ch. 1.4)\n\n### Accessing a shell at OSC\n\n1.  Go to <https://ondemand.osc.edu> in your browser, and log in.\n2.  Click on `Clusters` and then `Pitzer Shell Access`.\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: callout-warning\n#### Copying and pasting in this shell\n\nYou can't right-click in this shell, so to copy-and-paste:\n\n-   **Copy** simply by selecting text\n    (you should see a copy ({{< fa copy >}}) icon appear).\n-   **Paste** using <kbd>Ctrl</kbd>+<kbd>V</kbd>.\n\n{{< fa user-edit >}} Try copying and pasting a random word into your shell.\nThis may just work, you may get a permission pop-up, or it may silently fail ---\nif the latter, click on the clipboard icon in your browser's address bar\n(see red circle in screenshot below):\n\n![](img/pasting2.png)\n:::\n\n### The prompt\n\nInside your terminal, the \"prompt\" indicates that the shell is ready for a\ncommand. What is shown exactly varies across shells and can also be customized,\nbut our prompts at OSC should show the following information:\n\n`<username>@<node-name> <working-dir>]$`\n\nFor example (and _note that **`~`** means your Home dir_):\n\n``` bash-in-nocolor\n[jelmer@pitzer-login02 ~]$ \n```\n\nWe type our commands after the dollar sign, and then press <kbd>Enter</kbd> to\nexecute the command. When the command has finished executing, we'll get our\nprompt back and can type a new command.\n\n::: callout-tip\n#### Clearing the screen\nOSC prints welcome messages and storage quota information when you open a shell.\nTo reduce the amount of text on the screen, I will **clear** the screen now and regularly throughout.\nThis can be done with the keyboard shortcut **<kbd>Ctrl</kbd>+<kbd>L</kbd>**.\n\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### A few simple commands: `date` and `pwd`\n\nThe Unix shell comes with hundreds of \"commands\": small programs that perform\nspecific actions.\nIf you're familiar with R or Python, a Unix *command* is like an R/Python *function*.\n\nLet's start with a few simple commands:\n\n-   The `date` command prints the current date and time:\n\n    ``` bash\n    date\n    ```\n    ``` bash-out\n    Thu Feb 29 14:58:19 EST 2024\n    ```\n\n-   The `pwd` (Print Working Directory) command prints the path to the directory\n    you are currently located in:\n\n    ``` bash\n    pwd\n    ```\n    ``` bash-out\n    /users/PAS0471/jelmer\n    ```\n\nBoth of those commands provided us with some output. That output was **printed\nto screen**, which is the default behavior for nearly every Unix command.\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### The `cal` command --- and options & arguments\n\nThe `cal` command is another example of a command that simply prints some information to the screen,\nin this case a calendar.\nWe'll use it to learn about command *options* and *arguments*.\n\nInvoking `cal` without options or arguments will show the current month:\n\n```bash\ncal\n```\n``` bash-out\n    February 2024   \nSu Mo Tu We Th Fr Sa\n             1  2  3\n 4  5  6  7  8  9 10\n11 12 13 14 15 16 17\n18 19 20 21 22 23 24\n25 26 27 28 29\n```\n\n#### Option examples\n\nUse the *option* `-j` (dash and then j) for a Julian calendar,\nin which day numbering is continuous instead of restarting each month:\n\n```bash\n# Make sure to leave a space between `cal` and `-j`!\ncal -j\n```\n```bash-out\n       February 2024       \nSun Mon Tue Wed Thu Fri Sat\n                 32  33  34\n 35  36  37  38  39  40  41\n 42  43  44  45  46  47  48\n 49  50  51  52  53  54  55\n 56  57  58  59  60\n```\n\nUse the `-3` option to show 3 months (adding the previous and next month):\n\n```bash\ncal -3\n```\n``` bash-out\n    January 2024          February 2024          March 2024     \nSu Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa\n    1  2  3  4  5  6               1  2  3                  1  2\n 7  8  9 10 11 12 13   4  5  6  7  8  9 10   3  4  5  6  7  8  9\n14 15 16 17 18 19 20  11 12 13 14 15 16 17  10 11 12 13 14 15 16\n21 22 23 24 25 26 27  18 19 20 21 22 23 24  17 18 19 20 21 22 23\n28 29 30 31           25 26 27 28 29        24 25 26 27 28 29 30\n                                            31   \n```\n\nWe can always combine multiple options, for example:\n\n```bash\ncal -j -3\n```\n``` bash-out\n        January 2024                February 2024                  March 2024        \nSun Mon Tue Wed Thu Fri Sat  Sun Mon Tue Wed Thu Fri Sat  Sun Mon Tue Wed Thu Fri Sat\n      1   2   3   4   5   6                   32  33  34                       61  62\n  7   8   9  10  11  12  13   35  36  37  38  39  40  41   63  64  65  66  67  68  69\n 14  15  16  17  18  19  20   42  43  44  45  46  47  48   70  71  72  73  74  75  76\n 21  22  23  24  25  26  27   49  50  51  52  53  54  55   77  78  79  80  81  82  83\n 28  29  30  31               56  57  58  59  60           84  85  86  87  88  89  90\n                                                           91 \n```\n\nHandily, options can be \"pasted together\" like so (output not shown - same as above):\n\n```bash\ncal -j3\n```\n\n#### Options summary\n\nAs we've seen, options are specified with a dash `-` (or `--`, as you'll see later).\nSo far, we've only worked with the type of options that are also called \"**flags**\",\n_which change some functionality in an ON/OFF type way_:\n\n- Turning a Julian calender display ON with `-j`\n- Turning a 3-month display ON with `-3`.\n\nIn general terms, options **change the behavior** of a command.\n\n#### Arguments\n\nWhereas options change the behavior of a command,\narguments typically tell the command **what to operate on**.\nMost commonly, these are file or directory paths.\n\nAdmittedly, the `cal` command is not the best illustration of this pattern ---\nwhen you give it one argument, this is supposed to be the year to show a calendar for:\n\n```bash\ncal 2020\n```\n```bash-out\n                              2020                               \n\n       January               February                 March       \nSu Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa\n          1  2  3  4                      1    1  2  3  4  5  6  7\n 5  6  7  8  9 10 11    2  3  4  5  6  7  8    8  9 10 11 12 13 14\n12 13 14 15 16 17 18    9 10 11 12 13 14 15   15 16 17 18 19 20 21\n19 20 21 22 23 24 25   16 17 18 19 20 21 22   22 23 24 25 26 27 28\n26 27 28 29 30 31      23 24 25 26 27 28 29   29 30 31\n\n# [...output truncated, entire year is shown...]\n```\n\nWe can also combine options and arguments:\n\n```bash\ncal -j 2020\n```\n```bash-out\n                            2020                          \n\n          January                       February         \nSun Mon Tue Wed Thu Fri Sat   Sun Mon Tue Wed Thu Fri Sat\n              1   2   3   4                            32\n  5   6   7   8   9  10  11    33  34  35  36  37  38  39\n 12  13  14  15  16  17  18    40  41  42  43  44  45  46\n 19  20  21  22  23  24  25    47  48  49  50  51  52  53\n 26  27  28  29  30  31        54  55  56  57  58  59  60\n \n# [...output truncated, entire year is shown...]\n```\n  \nSo, arguments to a command:\n\n- Are not preceded by a `-` (or `--`)\n- If options and arguments are combined, arguments **come after** options^[\n  Though some commands are flexible and accept either order.].\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Getting help\n\nMany commands – *and other command-line programs!* – have a **`-h`** option for help,\nwhich usually gives a concise summary of the command's syntax,\ni.e. it's available options and arguments:\n\n```bash\ncal -h\n```\n```bash-out\n\nUsage:\n cal [options] [[[day] month] year]\n\nOptions:\n -1, --one        show only current month (default)\n -3, --three      show previous, current and next month\n -s, --sunday     Sunday as first day of week\n -m, --monday     Monday as first day of week\n -j, --julian     output Julian dates\n -y, --year       show whole current year\n -V, --version    display version information and exit\n -h, --help       display this help text and exit\n```\n\n::: {.callout-note collapse=\"true\"}\n### Another way to see documentation: the `man` command _(Click to expand)_\nAn alternative way of getting help for Unix commands is with the `man` command:\n\n```bash\nman cal\n```\n\nThis manual page often includes a lot more details than the `--help` output,\nand it is opened inside a \"pager\" rather than printed to screen:\ntype **<kbd>q</kbd>** to exit the pager that `man` launches.\n\n:::\n\n::: exercise\n#### {{< fa user-edit >}} Exercise: Interpreting the help output\n\n- Look through the options listed when you ran `cal -h`, and try an option we\n  haven't used yet^[There really is only one proper additional options: two others\n  reflect the defaults, and then there's the version option.].\n  (You can also combine this new option with other options, if you want.)\n\n<details><summary>Solution</summary>\n\n```bash\n# Print a calendar with Monday as the first day of th week (instead of the default, Sunday) \ncal -m\n```\n```bash-out\n    February 2024   \nMo Tu We Th Fr Sa Su\n          1  2  3  4\n 5  6  7  8  9 10 11\n12 13 14 15 16 17 18\n19 20 21 22 23 24 25\n26 27 28 29\n```\n\n</details>\n\n- Try using one or more options in their \"long form\" (with `--`).\n  Why would those be useful?\n\n<details><summary>Solution</summary>\n\nFor example:\n\n```bash\ncal --julian --monday\n```\n```bash-out\n       February 2024       \nMon Tue Wed Thu Fri Sat Sun\n             32  33  34  35\n 36  37  38  39  40  41  42\n 43  44  45  46  47  48  49\n 50  51  52  53  54  55  56\n 57  58  59  60\n```\n\nThe advantage of using long options is that it is much more likely that any reader of the code\n(including yourself next week) will immediately understand what these options are doing.\n\nNote that long options **cannot** be \"pasted together\" like short options.\n\n</details>\n\n- Bonus: Try to figure out / guess what the `cal [options] [[[day] month] year]` means.\n  Can you print a calendar for April 2017?\n\n<details><summary>Solution</summary>\n\nFirst of all, the square brackets around `options` and all of the possible arguments\nmeans that _none of these are required_ ---\nas we've seen, just `cal` (with no options or arguments) is a valid command.\n\nThe structure of the multiple square brackets around the day-month-year arguments indicate that:\n\n- _If_ you provide only one argument, it should be a year\n- _If_ you provide a second argument, it should be a month\n- _If_ you provide a third argument, it should be a day\n\nTherefore, to print a calendar for April 2017:\n\n```bash\ncal 4 2017\n```\n```bash-out\n     April 2017     \nSu Mo Tu We Th Fr Sa\n                   1\n 2  3  4  5  6  7  8\n 9 10 11 12 13 14 15\n16 17 18 19 20 21 22\n23 24 25 26 27 28 29\n30\n```\n\n</details>\n\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### `cd` and command \"actions\"\n\nAll the commands so far \"merely\" provided some information, which was printed to screen.\n\nBut many commands perform another kind of **action**.\nFor example, the command **`cd`** will change your *working* directory.\nAnd like many commands that perform a potentially invisible action,\n`cd` normally has **no output** at all.\n\nFirst, let's check again where we are --- we should be in our Home directory:\n\n```bash\n# (Note: you will have a different project listed in your Home dir. This is not important.)\npwd\n```\n```bash-out\n/users/PAS0471/jelmer\n```\n\nNow, let's use `cd` to move to another directory by specifying the *path* to that\ndirectory as an argument:\n\n``` bash\ncd /fs/ess/PAS2700\n```\n\n```bash\n# Double-check that we moved:\npwd\n```\n``` bash-out\n/fs/ess/PAS2700\n```\n\nIn summary:\n\n- Like `cal`, `cd` accepts an argument. Unlike `cal`, this argument takes the form\n  of a path that the command should operate on, which is much more typical.\n- `cd` gives no output when it successfully changed the working directory.\n  This is very common behavior for Unix commands that perform\n  operations: **when they succeed, they are silent**.\n\nLet's also see what happens when `cd` does not succeed — it gives an error:\n\n  ``` bash\n  cd /fs/ess/PAs2700\n  ```\n  \n  ``` bash-out\n  -bash: cd: /fs/ess/PAs2700: No such file or directory\n  ```\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: callout-note\n#### General shell tips\n\n-   Everything in the shell is **case-sensitive**, including commands and file names (hence the error above).\n-   Your **cursor** can be anywhere on a line (not just at the end) when you\n    press <kbd>Enter</kbd> to execute a command!\n-   Any text that comes after a **`#`** is considered a **comment** instead of code!\n\n``` bash\n# This entire line is a comment - you can run it and nothing will happen\npwd    # 'pwd' will be executed but everything after the '#' is ignored\n```\n\n``` bash-out\n/users/PAS0471/jelmer\n```\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Keyboard shortcuts\n\nUsing keyboard shortcuts help you work much more efficiently in the shell.\nAnd some are invaluable:\n\n-   **Cancel/stop/abort** --- If your prompt is \"missing\", the shell is still\n    busy executing your command, *or* you typed an incomplete command. To abort,\n    press <kbd>Ctrl</kbd>+<kbd>C</kbd> and you will get your prompt back.\n-   **Command history** --- `Up` / `Down` arrow keys to cycle through your command history.\n-   **Tab completion** --- The shell will auto-complete partial commands or file paths when you press <kbd>Tab</kbd>.\n\n::: exercise\n#### {{< fa user-edit >}} Practice with Tab completion & command history\n\n- Type **`/f`** and press <kbd>Tab</kbd> (will autocomplete to */fs/*)\n\n- Add **`e`** (*/fs/e*) and press <kbd>Tab</kbd> (will autocomplete to */fs/ess/*).\n\n- Add **`PAS`** (*/fs/ess/PAS*) and press <kbd>Tab</kbd>. Nothing should\n  happen: there are multiple (many!) options.\n\n- Press <kbd>Tab</kbd> <kbd>Tab</kbd> (i.e., twice in quick succession) and it should say:\n\n  ``` bash-out\n  Display all 503 possibilities? (y or n)\n  ```\n\n- Type `n` to answer no: we don't need to see all the dirs starting with `PAS`.\n\n- Add **`27`** (*/fs/ess/PAS27*) and press <kbd>Tab</kbd> (should autocomplete to */fs/ess/PAS2700*).\n\n- Press <kbd>Enter</kbd>. What does the resulting error mean?\n\n  ```bash-out-solo\n  bash: /fs/ess/PAS2700/: Is a directory\n  ```\n\n<details><summary>Click to see the solution</summary>\nBasically, everything you type in the shell should start with a command.\nJust typing the name of a dir or file will not make the shell print some info about\nor the contents of said dir or file, as you perhaps expected.\n</details>\n\n- Press **<kbd>⇧</kbd>** to get the previous \"command\" back on the prompt.\n\n- Press **<kbd>Ctrl</kbd>+<kbd>A</kbd>** to move to the beginning of the line at once.\n\n- Add `cd` and a space in front of the dir, and press <kbd>Enter</kbd> again.\n\n  ```bash\n  cd /fs/ess/PAS2700/\n  ```\n:::\n\n::: exercise\n#### {{< fa user-edit >}} Practice with canceling\n\nTo simulate a long-running command that we may want to abort, we can use the\n`sleep` command, which will make the computer wait for a specified amount of\ntime until giving your prompt back. Run the below command and instead of waiting\nfor the full 60 seconds, **press <kbd>Ctrl</kbd> + <kbd>C</kbd>** to get your prompt\nback sooner!\n\n``` bash\nsleep 60s\n```\n\nOr, use <kbd>Ctrl</kbd> + <kbd>C</kbd> after running this example of an\nincomplete command (an opening parenthesis `(`):\n\n``` bash\n(\n```\n:::\n\n::: {.callout-note collapse=\"true\"}\n#### Table with useful keyboard shortcuts  _(Click to expand)_\n\nNote that even on Macs, you should use <kbd>Ctrl</kbd> instead of switching them\nout for <kbd>Cmd</kbd> as you may be used to doing (in some cases, like copy/paste,\nboth work).\n\n| Shortcut | Function |\n|-----|------------|\n| <kbd>Tab</kbd> | Tab completion |\n| <kbd>⇧</kbd> / <kbd>⇩</kbd> | Cycle through previously issued commands | |\n| <kbd>Ctrl</kbd>(+<kbd>Shift</kbd>)+<kbd>C</kbd> | Copy selected text | |\n| <kbd>Ctrl</kbd>(+<kbd>Shift</kbd>)+<kbd>V</kbd> | Paste text from clipboard |\n| <kbd>Ctrl</kbd>+<kbd>A</kbd> / <kbd>Ctrl</kbd>+<kbd>E</kbd> | Go to beginning/end of line |\n| <kbd>Ctrl</kbd>+<kbd>U</kbd> /<kbd>Ctrl</kbd>+<kbd>K</kbd> | Cut from cursor to beginning / end of line |\n| <kbd>Ctrl</kbd>+<kbd>W</kbd> | ~~Cut word before before cursor~~ (Only works on Macs in our shell in the browser!) |\n| <kbd>Ctrl</kbd>+<kbd>Y</kbd> | Paste (\"yank\") text that was cut with one of the shortcuts above |\n| <kbd>Alt</kbd>+<kbd>.</kbd> / <kbd>Esc</kbd>+<kbd>.</kbd>  | Retrieve last argument of previous command (very useful!) (<kbd>Esc</kbd>+<kbd>.</kbd> for Mac) |\n| <kbd>Ctrl</kbd>+<kbd>R</kbd> | Search history: press <kbd>Ctrl</kbd>+<kbd>R</kbd> again to cycle through matches, <kbd>Enter</kbd> to put command in prompt. |\n| <kbd>Ctrl</kbd>+<kbd>C</kbd> | Cancel (kill/stop/abort) currently active command |\n| <kbd>Ctrl</kbd>+<kbd>D</kbd> | Exit (a program or the shell, depending on the context) (same as `exit` command) |\n| <kbd>Ctrl</kbd>+<kbd>L</kbd> | Clear the screen (same as `clear` command) |\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Environment variables\n\nYou may be familiar with the concept of **variables** from previous experience with perhaps R or another language.\nVariables can hold values and other pieces of data and are essential in programming.\n\n- Assigning and printing the value of a variable **in R**:\n\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  # (Don't run this)\n  x <- 5\n  x\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ``` styled-output\n  [1] 5\n  ```\n  \n  \n  :::\n  :::\n\n\n\n\n- Assigning and printing the value of a variable **in the Unix shell**:\n\n  ``` bash\n  x=5\n  echo $x\n  ```\n  ``` bash-out\n  5\n  ```\n\n::: callout-tip\n#### In the Unix shell code above, note that:\n\n-   There cannot be any **spaces** around the **`=`** in `x=5`.\n-   You need a **`$` prefix** to *reference* (but not to *assign*) variables in the shell[^4].\n-   You need the **`echo`** command, a general command to print text, to print the value of `$x` (cf. in R).\n\nBy the way, `echo` can also print literal text (as shown below) or combinations\nof literals and variables (next exercise):\n    \n```bash\necho \"Welcome to PLNTPTH 6193\"\n```\n```bash-out\nWelcome to PLNTPTH 6193\n```\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n:::\n\n[^4]: Because of this, anytime you see a word/string that starts with a `$` in the shell,\nyou can safely assume that it is a variable.\n\n**Environment variables** are pre-existing variables that have been automatically assigned values. Two examples:\n\n``` bash\n# $HOME contains the path to your Home dir:\necho $HOME\n```\n\n``` bash-out\n/users/PAS0471/jelmer\n```\n\n``` bash\n# $USER contains your user name:\necho $USER\n```\n\n``` bash-out\njelmer\n```\n\n::: exercise\n#### {{< fa user-edit >}} **Exercise**: environment variables\n\nUsing an environment variable, print \"_Hello, my name is \\<your username\\>_\" (e.g. \"Hello, my name is natalie\").\n\n<details><summary>*Click to see the solution*</summary>\n\n``` bash\n# (This would also work without the \" \" quotes)\necho \"Hello, my name is $USER\"\n```\n\n``` bash-out\nHello, my name is jelmer\n```\n\n</details>\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Create your own dir & get the CSB data\n\nOur base OSC directory is the **`/fs/ess/PAS2700`** dir we are currently in.\nNow, let's all create our own subdir in here, and get the data from the CSB book.\n\n-   Create a directory for yourself using the **`mkdir`** (**m**a**k**e **dir**) command:\n\n    ```bash\n    mkdir users/$USER\n    ```\n\n-   Move there using `cd`:\n\n    ```bash\n    # (Instead of $USER, you can also start typing your username and press Tab)\n    cd users/$USER\n    ```\n\n-   Get the files associated with the CSB book by \"*cloning*\" (downloading) its Git repository:\n\n    ```bash\n    git clone https://github.com/CSB-book/CSB.git\n    ```\n\n-   Move into the *sandbox* dir for the Unix chapter (remember to use tab completion):\n\n    ```bash\n    cd CSB/unix/sandbox\n    ```\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Paths & navigation shortcuts\n\n#### Absolute (full) paths versus relative paths\n\n- **Absolute (full) paths** (e.g. `/fs/ess/PAS2700`) \\\n  Paths that begin with a `/` always start from the computer's root directory,\n  and are called \"absolute paths\".\\\n  *(They are equivalent to GPS coordinates for a geographical location,*\n  *as they work regardless of where you are*).\n\n- **Relative paths** (e.g. `CSB/unix/sandbox`)\\\n  Paths that instead start from your current working directory are called \"relative paths\".\\\n    *(These work like directions along the lines of \"take the second left:\"*\n    *they depend on your current location.)*\n\nIn [this tutorial](reprod/project-org.qmd),\nyou can find out talk more about the distinction between absolute and relative paths,\nand their respective merits.\n\n#### Path shortcuts\n\n- **`~`** (a tilde) --- represents your Home directory.\n  For example, `cd ~` moves you to your Home dir.\n- **`.`** (a single period) --- represents the current working directory\n  (we'll soon see how why that can be useful).\n- **`..`** (two periods) --- Represents the directory \"one level up\", i.e. towards the computer's root dir.\n\nSome examples of `..`:\n\n- Use `..` to go up one level in the dir hierarchy:\n\n  ```bash\n  pwd\n  ```\n  ```bash-out\n  /fs/ess/PAS2700/users/jelmer/CSB/unix/sandbox\n  ```\n  ```bash\n  cd ..\n  pwd\n  ```\n  ``` bash-out\n  /fs/ess/PAS2700/users/jelmer/CSB/unix\n  ```\n\n- This pattern can be continued all the way to the root of the computer, so `../..` means two levels up:\n\n  ``` bash\n  cd ../..\n  pwd\n  ```\n  ``` bash-out\n  /fs/ess/PAS2700/users/jelmer\n  ```\n\n::: callout-tip\n#### These path shortcuts work with many commands\nThese are *general shell shortcuts* that work with **any** command that accepts a path/file name.\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: exercise\n#### {{< fa user-edit >}} Exercise\n\n- **A)** Use a relative path to move back to the `/fs/ess/PAS2700/users/$USER/CSB/unix/sandbox` dir.\n\n<details><summary>*(Click for the solution)*</summary>\n\n``` bash\ncd CSB/unix/sandbox\n```\n\n</details>\n\n- **B)** Use a relative path (with `..`) to move into the `/fs/ess/PAS2700/users/$USER/CSB/unix/data` dir.\n\n<details><summary>*(Click for the solution)*</summary>\n\n``` bash\ncd ../data\n```\n\nYou may have done this in two steps, because you may not have realized that you\ncan \"add to\" a path after `..` like we did above. So you may have done this:\n\n```bash\ncd ..\ncd data\n```\n\nThat's OK, but is obviously more typing.\n\n</details>\n\n- **C)** The `ls` command lists files and dirs, and accepts one or more paths as arguments.\n  Use `ls` to list the files in your Home dir with a shortcut and without moving there.\n\n<details><summary>*(Click for the solution)*</summary>\n\n- With the `~` shortcut:\n\n``` bash\nls ~\n# (Output not shown)\n```\n\n- With the `$HOME` environment variable:\n\n``` bash\nls $HOME\n# (Output not shown)\n```\n\n</details>\n:::\n\n<br>\n\n## Basic Unix commands (Ch. 1.5)\n\n### `ls` to list files\n\nThe `ls` command, short for \"list\", will list files and directories ---\nby default those in your current working dir:\n\n``` bash\n# (You should be in /fs/ess/PAS2700/users/$USER/CSB/unix/data)\nls\n```\n``` bash-out\nBuzzard2015_about.txt  Gesquiere2011_about.txt  Marra2014_about.txt   miRNA                   Pacifici2013_data.csv  Saavedra2013_about.txt\nBuzzard2015_data.csv   Gesquiere2011_data.csv   Marra2014_data.fasta  Pacifici2013_about.txt  Saavedra2013\n```\n\n::: {.callout-tip collapse=\"true\"}\n#### `ls` output colors *(click to expand)*\n\nThe `ls` output above does not show the different colors you should see in your shell — the most common ones are:\n\n-   Entries in [blue]{style=\"color: #0328fc\"} are directories (like `miRNA` and `Saavedra2013` above)\n-   Entries in black are regular files (like all other entries above)\n-   Entries in [red]{style=\"color: #d92118\"} are compressed files (we'll see examples of this later).\n:::\n\n_For which dir_ `ls` lists its contents can be changed with arguments,\nand _how_ it shows the output can be changed with options.\nFor example, we can call `ls` with the **option `-l`** (lowercase L):\n\n``` bash\nls -l \n```\n``` bash-out\ntotal 1793\n-rw-rw----+ 1 jelmer PAS0471     562 Feb 24 20:30 Buzzard2015_about.txt\n-rw-rw----+ 1 jelmer PAS0471   39058 Feb 24 20:30 Buzzard2015_data.csv\n-rw-rw----+ 1 jelmer PAS0471     447 Feb 24 20:30 Gesquiere2011_about.txt\n-rw-rw----+ 1 jelmer PAS0471   38025 Feb 24 20:30 Gesquiere2011_data.csv\n-rw-rw----+ 1 jelmer PAS0471     756 Feb 24 20:30 Marra2014_about.txt\n-rw-rw----+ 1 jelmer PAS0471  566026 Feb 24 20:30 Marra2014_data.fasta\ndrwxrwx---+ 2 jelmer PAS0471    4096 Feb 24 20:30 miRNA\n-rw-rw----+ 1 jelmer PAS0471     520 Feb 24 20:30 Pacifici2013_about.txt\n-rw-rw----+ 1 jelmer PAS0471 1076150 Feb 24 20:30 Pacifici2013_data.csv\ndrwxrwx---+ 2 jelmer PAS0471    4096 Feb 24 20:30 Saavedra2013\n-rw-rw----+ 1 jelmer PAS0471     322 Feb 24 20:30 Saavedra2013_about.txt\n```\n\nIt lists the same items as earlier, but **printed in a different format**:\none item per line, with additional information such as the date and time each file was last modified,\nand file sizes in bytes (to the left of the date).\n\nLet's add another option, **`-h`**:\n\n``` bash\nls -lh\n```\n``` bash-out\ntotal 1.8M\n-rw-rw----+ 1 jelmer PAS0471  562 Feb 24 20:30 Buzzard2015_about.txt\n-rw-rw----+ 1 jelmer PAS0471  39K Feb 24 20:30 Buzzard2015_data.csv\n-rw-rw----+ 1 jelmer PAS0471  447 Feb 24 20:30 Gesquiere2011_about.txt\n-rw-rw----+ 1 jelmer PAS0471  38K Feb 24 20:30 Gesquiere2011_data.csv\n-rw-rw----+ 1 jelmer PAS0471  756 Feb 24 20:30 Marra2014_about.txt\n-rw-rw----+ 1 jelmer PAS0471 553K Feb 24 20:30 Marra2014_data.fasta\ndrwxrwx---+ 2 jelmer PAS0471 4.0K Feb 24 20:30 miRNA\n-rw-rw----+ 1 jelmer PAS0471  520 Feb 24 20:30 Pacifici2013_about.txt\n-rw-rw----+ 1 jelmer PAS0471 1.1M Feb 24 20:30 Pacifici2013_data.csv\ndrwxrwx---+ 2 jelmer PAS0471 4.0K Feb 24 20:30 Saavedra2013\n-rw-rw----+ 1 jelmer PAS0471  322 Feb 24 20:30 Saavedra2013_about.txt\n```\n\n<details><summary>What is different about the output, and what do you think that means? *(Click to see the answer)*</summary>\n\nThe only difference is in the format of the column reporting the sizes of the items listed.\n\nWe now have \"Human-readable filesizes\" (hence `-h`), where sizes on the scale of kilobytes will be shown \nwith `K`s, of megabytes with `M`s, and of gigabytes with `G`s. That can be really useful especially for very large files.\n\n</details>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nWe can also list files in directories other than the one we are in, by specifying that dir as an argument:\n\n``` bash\nls miRNA\n```\n``` bash-out\nggo_miR.fasta  hsa_miR.fasta  miR_about.txt  miRNA_about.txt  ppa_miR.fasta  ppy_miR.fasta  ptr_miR.fasta  ssy_miR.fasta\n```\n\nAnd like we saw with `cal`, we can combine options and arguments:\n\n``` bash\nls -lh miRNA\n```\n``` bash-out\ntotal 320K\n-rw-rw----+ 1 jelmer PAS0471  18K Feb 24 20:30 ggo_miR.fasta\n-rw-rw----+ 1 jelmer PAS0471 131K Feb 24 20:30 hsa_miR.fasta\n-rw-rw----+ 1 jelmer PAS0471  104 Feb 24 20:30 miR_about.txt\n-rw-rw----+ 1 jelmer PAS0471  104 Feb 24 20:30 miRNA_about.txt\n-rw-rw----+ 1 jelmer PAS0471 4.0K Feb 24 20:30 ppa_miR.fasta\n-rw-rw----+ 1 jelmer PAS0471  33K Feb 24 20:30 ppy_miR.fasta\n-rw-rw----+ 1 jelmer PAS0471  29K Feb 24 20:30 ptr_miR.fasta\n-rw-rw----+ 1 jelmer PAS0471  495 Feb 24 20:30 ssy_miR.fasta\n```\n\nLet's move into the `sandbox` dir in preparation for the next sections:\n\n```bash\ncd ../sandbox\n\nls\n```\n```bash-out\nPapers and reviews\n```\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### `cp` to copy files\n\nThe `cp` command copies files and/or dirs from one location to another.\nIt has two required arguments: what you want to copy (_source_),\nand where you want to copy it to (_destination_).\nIts basic syntax is `cp <source> <destination>`.\n\nFor example, to copy a file to our current working directory using the `.` shortcut,\nkeeping the original file name:\n\n```bash\ncp ../data/Buzzard2015_about.txt .\n```\n\nWe can also copy using a new name for the copy:\n\n```bash\ncp ../data/Buzzard2015_about.txt buzz2.txt\n```\n\n`cp` will by default refuse to copy directories and their contents ---\nthat is, it is not \"recursive\" by default.\nThe `-r` option is needed for recursive copying:\n\n```bash\ncp -r ../data/ . \n```\n\nCheck the contents of the `sandbox` dir again now that we've copied several items there:\n\n```bash\nls\n```\n```bash-out\nbuzz2.txt  Buzzard2015_about.txt  data  Papers and reviews\n```\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### `mv` to move and rename files\n\nUse **`mv`** both to move and rename files (this is fundamentally the same operation):\n\n```bash\n# Same directory, different file name (\"renaming\")\nmv buzz2.txt buzz_copy.txt\n```\n\n```bash\n# Different directory, same file name (\"moving\")\nmv buzz_copy.txt data/\n```\n\nUnlike `cp`, `mv` is recursive by default, so you won't need the `-r` option.\n\n::: callout-tip\n#### Both the `mv` and `cp` commands will by default:\n\n- Not report what they do: no output = success\n  (use the `-v` option for _verbose_ to make them report what they do).\n- Overwrite existing files without reporting this\n  (use the `-i` option for _interactive_ to make them ask before overwriting).\n  \n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### `rm` to remove files and dirs\n\nThe **`rm`** command removes files and optionally dirs --- here,\nwe'll remove the file copy we made above: \n\n```bash\nrm Buzzard2015_about.txt\n```\n\nLike with `cp`, the **`-r`** option is needed to make the command work recursively:\n\n```bash\n# First we create 3 levels of dirs - we need `-p` to make mkdir work recursively:\nmkdir -p d1/d2/d3\n\n# Then we try to remove the d1 dir - which fails:\nrm d1\n```\n```bash-out\nrm: cannot remove ‘d1’: Is a directory\n```\n\n```bash\n# But it does work (silently!) with the '-r' option:\nrm -r d1\n```\n\n::: {.callout-warning collapse=\"true\"}\n#### There is no thrash bin when deleting files in the shell, so use `rm` with caution! _(Click to expand)_\n\n`rm -r` can be very dangerous --- for example `rm -r /` would at least attempt\nto remove the entire contents of the computer, including the operating system.\n\nA couple ways to take precautions:\n\n- You can add the `-i` option, which will have you confirm each individual removal (can be tedious)\n- When you _intend_ to remove an empty dir, you can use the `rmdir` command which will\n  do just (and only) that --- that way, if the dir isn't empty after all, you'll get an error.\n\n:::\n\n::: exercise\n#### {{< fa user-edit >}} Bonus exercise: `cp` and `mv` behavior\n\nFor both `cp` and `mv`, when operating on files (and this works equivalently for dirs):\n\n- If the destination is an existing dir, the file will go into that dir and keep its original name.\n- If the destination is _not_ an existing dir, the (last bit of the) destination specifies the new file name.\n- A trailing slash in the destination makes explicit that you are referring to a dir and not a file.\n\n-----\n\nWith that in mind, try to answer the following questions about this command:\n\n```bash\ncp Buzzard2015_about.txt more_data/\n```\n\n- What do you think the command would do or attempt to do?\n- Do you think the command will succeed?\n- What would the command have done if we had omitted the trailing forward slash?\n\n<details><summary>Click to see the solution</summary>\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n- Because we put a trailing forward slash in `more_data/`, we are making clear\n  that we are referring to a directory.\n  So the file should be copied into a dir `more_data`, and keep the same file name.\n  \n- However, the `more_data/` dir does not exist, and `cp` will not create\n  a dir on the fly, so this will fail:\n\n  ```bash\n  cp Buzzard2015_about.txt more_data/\n  ```\n  ```bash-out\n  cp: cannot create regular file ‘more_data/’: Not a directory\n  ```\n\n- If we had omitted the trailing forward slash, we would have created a copy\n  of the file with *file* name `more_data` (note that no file extension is needed, per se).\n\n- P.S: To make the original intention work, first create the destination dir:\n\n  ```bash\n  mkdir more_data\n  cp Buzzard2015_about.txt more_data/\n  ```\n  \n  Note also that once the `more_data` dir exists, it **does not** make a difference\n  whether or not you using a trailing slash (!).\n\n</details>\n\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Viewing and processing text files\n\n```bash\ncd ../data   # Move to the data dir for the next commands\n```\n\n#### `cat`\n\nThe **`cat`** command will print the entire contents of (a) file(s) to screen:\n\n```bash\ncat Marra2014_about.txt\n```\n```bash-out\nData published by:\nMarra NJ, DeWoody JA (2014) Transcriptomic characterization of the immunogenetic repertoires of heteromyid rodents. BMC Genomics 15: 929. http://dx.doi.org/10.1186/1471-2164-15-929\n\nData description:\nFile D_spec_spleen_filtered.fasta (57.01Mb) contains Dipodomys spectabilis spleen transcriptome data. Combined assembly of 454 reads and fragmented Illumina assembly (see methods of associated paper) in gsAssembler version 2.6.\nNote that we truncated the original file to 1% of its original size and named it Marra2014_data.txt\n\nData taken from:\nMarra NJ, DeWoody JA (2014) Data from: Transcriptomic characterization of the immunogenetic repertoires of heteromyid rodents. Dryad Digital Repository. http://dx.doi.org/10.5061/dryad.qn474\n```\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n#### `head` and `tail`\n\nThe **`head`** and **`tail`** commands will print the first or last lines of a file:\n\n- `head` & `tail`'s defaults are to print 10 lines:\n\n  ```bash\n  head Gesquiere2011_data.csv\n  ```\n  ```bash-out\n  maleID  GC      T\n  1       66.9    64.57\n  1       51.09   35.57\n  1       65.89   114.28\n  1       80.88   137.81\n  1       32.65   59.94\n  1       60.52   101.83\n  1       65.89   65.84\n  1       52.72   43.98\n  1       84.85   102.31\n  ```\n\n- Use the `-n` option to specify the number of lines to print:\n\n  ```bash\n  head -n 3 Gesquiere2011_data.csv\n  ```\n  ```bash-out\n  maleID  GC      T\n  1       66.9    64.57\n  1       51.09   35.57\n  ```\n\n- A neat trick with `tail` is to *start at* a specific line, often used to skip the header line,\n  like in this example^[We'll see this in action in a bit]:\n\n  ```bash\n  tail -n +2 Gesquiere2011_data.csv\n  ```\n  ```bash-out\n  1       66.9    64.57\n  1       51.09   35.57\n  1       65.89   114.28\n  1       80.88   137.81\n  1       32.65   59.94\n  1       60.52   101.83\n  1       65.89   65.84\n  1       52.72   43.98\n  1       84.85   102.31\n  1       98.25   149.61\n  [...output truncated...]\n  ```\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n#### `wc -l`\n\nThe **`wc`** command is different from the previous commands, which all printed file contents.\nBy default, `wc` will count lines, words, and characters ---\nbut it is most commonly used to only **count lines**, with the `-l` option:\n\n```bash\nwc -l Marra2014_about.txt\n```\n```bash-out\n9 Marra2014_about.txt\n```\n\n<br>\n\n## Advanced Unix commands (Ch. 1.6)\n\nStart by moving back to the `sandbox` dir:\n\n```bash\ncd ../sandbox\n```\n\n### Standard output and redirection\n\nThe regular output of a command is also called **\"standard out\"** (\"*stdout*\").\nAs we've seen many times now, such output is by default printed to screen,\nbut it can alternatively be \"**redirected**\", such as into a file.\n\nWith \"**`>`**\", we **redirect** output to a file:\n\n-   If the file doesn't exist, it will be *created*.\n-   If the file does exist, any contents will be *overwritten*.\n\nFirst, let's remind ourselves what `echo` does without redirection:\n\n```bash\necho \"My first line\"\n```\n```bash-out\nMy first line\n```\n\nNow, let's redirect to a new file `test.txt` --- no output is printed, as it went into the file:\n\n```bash\necho \"My first line\" > test.txt\n```\n```bash\ncat test.txt\n```\n```bash-out\nMy first line\n```\n\nLet's redirect another line into that same file:\n\n```bash\necho \"My second line\" > test.txt\ncat test.txt\n```\n```bash-out\nMy second line\n```\n\nThat may not have been what we intended! As explained above, the file was overwritten. \n\nWith \"**`>>`**\", however, we **append** the output to a file:\n\n```bash\necho \"My third line\" >> test.txt\ncat test.txt\n```\n```bash-out\nMy second line\nMy third line\n```\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Standard input and pipes\n\nRecall from today's previous examples that a file name can be given as an argument\nto many commands --- for example, see the following sequence of commands:\n\n```bash\n# First we redirect the ls output to a file\nls ../data/Saavedra2013 > filelist.txt\n\n# Let's check what that looks like:\nhead -n 5 filelist.txt\n```\n```bash-out\nn10.txt\nn11.txt\nn12.txt\nn13.txt\nn14.txt\n```\n```bash\n# Then we count the nr. of lines, which is the number of files+dirs in Saavedra2013:\nwc -l filelist.txt\n```\n```bash-out\n59 filelist.txt\n```\n\nHowever, most commands *also* accept input from so-called \"standard input\" (*stdin*)\nusing the **pipe**, \"**`|`**\":\n\n```bash\nls ../data/Saavedra2013 | wc -l\n```\n```bash-out\n59\n```\n\nWhen we use the pipe, the output of the command on the left-hand side (a file listing, in this case)\nis no longer printed to screen but is **redirected into the `wc` command**,\nwhich will gladly accept input that way instead of via an argument with a file name like in the earlier example.\n\nPipes are useful because they avoid having to write/read intermediate files ---\nthis saves typing, makes the operation quicker, and reduces file clobber.\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Selecting columns using `cut`\n\nWe'll now turn to some commands that may be described as Unix \"data tools\":\n`cut`, `sort`, `uniq`, `tr`, and `grep`.\n\nMost of the examples will use the file `Pacifici2013_data.csv`,\nso let's have a look at the contents of that file first:\n\n```bash\ncd ../data\nhead -n 3 Pacifici2013_data.csv\n```\n```bash-out\nTaxID;Order;Family;Genus;Scientific_name;AdultBodyMass_g;Sources_AdultBodyMass;Max_longevity_d;Sources_Max_longevity;Rspan_d;AFR_d;Data_AFR;Calculated_GL_d;GenerationLength_d;Sources_GL\n7580;Rodentia;Cricetidae;Eligmodontia;Eligmodontia typus;17.37;PanTHERIA;292;PanTHERIA;254.64;73.74;calculated;147.5856;147.5856;Rspan-AFR(SM+Gest)\n42632;Rodentia;Cricetidae;Microtus;Microtus oregoni;20.35;PanTHERIA;456.25;PanTHERIA;445.85;58.06;calculated;187.3565;187.3565;Rspan-AFR(SM+Gest)\n```\n\n::: {.callout-note collapse=\"true\"}\n#### Tabular plain-text files _(Click to expand)_\n\nIn bioinformatics, we usually work with so-called \"**plain-text**\" files.\nThese are simple files that can be opened by any text editor and Unix shell tool,\nas opposed to more complex \"binary\" formats like Excel or Word files.\nAlmost all common genomics file formats are plain-text.\n\n\"**Tabular**\" files contain data that is arranged in a rows-and-columns format,\nlike a table or an Excel worksheet.\n\n**Plain-text tabular** files, like `Pacifici2013_data.csv`,\ncontain a specific \"delimiter\" to delimit columns --- most commonly:\n\n- A Tab, and such files are often stored with a **`.tsv`** extension for Tab-Separated Values (\"TSV file\").\n- A comma, and such files are often stored with a **`.csv`** extension for Comma-Separated Values (\"CSV file\").\n\n:::\n\n<details><summary>What delimiter does the `Pacifici2013_data.csv` file appear to contain? _(Click for the answer)_</summary>\nFrom looking at the first couple of lines that we printed above, the delimiter\nis a semicolon `;` --- \"even though\" the file has a `.csv` extension.\n</details>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\nThe `cut` command will select/\"cut out\" one or more columns from a tabular file:\n\n- We'll always have to use the **`-f`** option to specify the **desired column(s) / \"field\"(s)**.\n- Because its default column delimiter is a Tab, for this file,\n  we'll have to specify the **delimiter** with **`-d`**.\n\n```bash\n# Select the first column of the file:\ncut -d \";\" -f 1 Pacifici2013_data.csv\n```\n```bash-out\nTaxID\n7580\n42632\n42653\n42662\n16652\n[...output truncated...]\n```\n\nThat worked, but a ton of output was printed, and we may find ourselves scrolling to\nthe top to see the first few lines --\nin many cases, it can be useful to **pipe the output to `head`** to see if our command works:\n\n```bash\ncut -d \";\" -f 1 Pacifici2013_data.csv | head -n 3\n```\n```bash-out\nTaxID\n7580\n42632\n```\n\n::: {.callout-tip collapse=\"true\"}\n#### Selecting multiple columns with `cut` _(Click to expand)_\n\nTo select **multiple columns**, use a range or comma-delimited list:\n\n```bash\ncut -d \";\" -f 1-4 Pacifici2013_data.csv | head -n 3\n```\n```bash-out\nTaxID;Order;Family;Genus\n7580;Rodentia;Cricetidae;Eligmodontia\n42632;Rodentia;Cricetidae;Microtus\n```\n\n```bash\ncut -d \";\" -f 2,8 Pacifici2013_data.csv | head -n 3\n```\n```bash-out\nOrder;Max_longevity_d\nRodentia;292\nRodentia;456.25\n```\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Combining `cut`, `sort`, and `uniq` to create a list\n\nLet's say we want an alphabetically sorted list of animal *orders* from the\n`Pacifici2013_data.csv` file.\nTo do this, we'll need two new commands:\n\n- **`sort`** to sort/order/arrange rows, by default in alphanumeric order.\n- **`uniq`** to remove duplicates (i.e., keep all distinct) entries _from a sorted file/list_\n\nWe'll build up a small \"pipeline\" to do this, step-by-step and piping\nthe output into `head` every time.\nFirst, we get rid of the header line with our `tail` trick:\n\n```bash\ntail -n +2 Pacifici2013_data.csv | head -n 5\n```\n```bash-out\n7580;Rodentia;Cricetidae;Eligmodontia;Eligmodontia typus;17.37;PanTHERIA;292;PanTHERIA;254.64;73.74;calculated;147.5856;147.5856;Rspan-AFR(SM+Gest)\n42632;Rodentia;Cricetidae;Microtus;Microtus oregoni;20.35;PanTHERIA;456.25;PanTHERIA;445.85;58.06;calculated;187.3565;187.3565;Rspan-AFR(SM+Gest)\n42653;Rodentia;Cricetidae;Peromyscus;Peromyscus gossypinus;27.68;PanTHERIA;471.45833335;PanTHERIA;444.87833335;72.58;calculated;201.59471667;201.5947166715;Rspan-AFR(SM+Gest)\n42662;Macroscelidea;Macroscelididae;Elephantulus;Elephantulus myurus;59.51;PanTHERIA;401.5;PanTHERIA;412.34;90.48;calculated;210.0586;210.0586;Rspan-AFR(SM+Gest)\n16652;Rodentia;Cricetidae;Peromyscus;Peromyscus boylii;23.9;PanTHERIA;547.5;PanTHERIA;514.13;79.97;calculated;229.0677;229.0677;Rspan-AFR(SM+Gest)\n```\n\nSecond, we select our column of interest with `cut`:\n\n```bash\ntail -n +2 Pacifici2013_data.csv | cut -d \";\" -f 2 | head -n 5\n```\n```bash-out\nRodentia\nRodentia\nRodentia\nMacroscelidea\nRodentia\n```\n\nThird, we pipe to `sort` to sort the result:\n\n```bash\ntail -n +2 Pacifici2013_data.csv | cut -d \";\" -f 2 | sort | head -n 5\n```\n```bash-out\nAfrosoricida\nAfrosoricida\nAfrosoricida\nAfrosoricida\nAfrosoricida\n```\n\nFourth and finally, we use `uniq` to only keep unique rows (values):\n\n```bash\ntail -n +2 Pacifici2013_data.csv | cut -d \";\" -f 2 | sort | uniq\n```\n```bash-out\nAfrosoricida\nCarnivora\nCetartiodactyla\nChiroptera\nCingulata\nDasyuromorphia\nDermoptera\nDidelphimorphia\n[...output truncated...]\n```\n\n::: {.callout-note collapse=\"true\"}\n#### Get a count table with `uniq -c` _(Click to expand)_\n\nWith a very small modification to our pipeline, using `uniq`'s `-c` option (for count),\nwe can generate a \"count table\" instead of a simple list:\n\n```bash\ntail -n +2 Pacifici2013_data.csv | cut -d \";\" -f 2 | sort | uniq -c\n```\n```bash-out\n     54 Afrosoricida\n    280 Carnivora\n    325 Cetartiodactyla\n   1144 Chiroptera\n     21 Cingulata\n[...output truncated...]\n```\n\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### `grep` to print lines matching a pattern\n\nThe `grep` command is useful to find specific text or patterns in a file.\nBy default, it will **print each line that contains a \"match\" in full**.\nIt's basic syntax is `grep \"<pattern>\" file`.\n\n\nFor example, this will print all lines from `Pacifici2013_data.csv` that contain \"Vombatidae\":\n\n```bash\ngrep \"Vombatidae\" Pacifici2013_data.csv\n```\n```bash-out\n40555;Diprotodontia;Vombatidae;Lasiorhinus;Lasiorhinus latifrons;26163.8;PanTHERIA;9928;\"PanTHERIA;AnAge\";9317.5;652.24;calculated;3354.315;3354.315;Rspan-AFR(SM+Gest)\n40556;Diprotodontia;Vombatidae;Vombatus;Vombatus ursinus;26000;PanTHERIA;10238.25;\"PanTHERIA;AnAge\";9511.6;783.65;calculated;3542.014;3542.014;Rspan-AFR(SM+Gest)\n11343;Diprotodontia;Vombatidae;Lasiorhinus;Lasiorhinus krefftii;31849.99;PanTHERIA;10950;\"PanTHERIA;AnAge\";no information;no information;no information;no information;3354.315;Mean_congenerics_same_body_mass\n```\n\nInstead of printing matching lines, we can also **count** them with the `-c` option:\n\n```bash\ngrep -c \"Chiroptera\" Pacifici2013_data.csv\n```\n```bash-out\n1144\n```\n\nThe option `-v` **inverts** `grep`'s behavior and will print all lines _not_ matching the pattern ---\nhere, we'll combine `-v` and `-c` to count the number of lines that do not contain \"Vombatidae\":\n\n```bash\ngrep -vc \"Vombatidae\" Pacifici2013_data.csv\n```\n```bash-out\n5424\n```\n\n::: callout-note\n#### `grep` tips\n\n- It is best to always use quotes around the pattern.^[Even though for \"literal string\" like in the examples\nabove, as opposed to regular expressions, this is not strictly necessary, it's good habit to always quote.]\n- Incomplete matches, including in individual words, work: \"`Vombat`\" matches `Vombatidae`.\n- `grep` has many other useful options:\n  - `-i` to ignore case\n  - `-r` to search files recursively\n  - `-w` to match \"words\"\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Substituting characters using `tr`\n\n`tr` for **`tr`**anslate will substitute characters – here, any `a` for a `b`:\n\n```bash\necho \"aaaabbb\" | tr a b\n```\n```bash-out\nbbbbbbb\n```\n\nOddly enough `tr` does not take a file name as an argument,\nso how can we provide it with input from a file?\nThe easiest way is by using a pipe (note that the book also shows another method):\n\n```bash\ncat Pacifici2013_data.csv | tr \";\" \"\\t\" | head -n 3\n```\n```bash-out\nTaxID   Order   Family  Genus   Scientific_name AdultBodyMass_g Sources_AdultBodyMass   Max_longevity_d Sources_Max_longevity   Rspan_d AFR_d   Data_AFR        Calculated_GL_d   GenerationLength_d      Sources_GL\n7580    Rodentia        Cricetidae      Eligmodontia    Eligmodontia typus      17.37   PanTHERIA       292     PanTHERIA       254.64  73.74   calculated      147.5856  147.5856        Rspan-AFR(SM+Gest)\n42632   Rodentia        Cricetidae      Microtus        Microtus oregoni        20.35   PanTHERIA       456.25  PanTHERIA       445.85  58.06   calculated      187.3565  187.3565        Rspan-AFR(SM+Gest)\n```\n\nThe example above converted the `;` delimited to a `Tab` (i.e., a CSV file to a TSV file),\nwhere **`\\t`** is a regular expression meaning Tab.\n(Though note that we didn't modify the original file nor saved the output in a new file.)\n\n::: {.callout-note collapse=\"true\"}\n#### Deletion and \"squeezing\" with `tr` _(Click to expand)_\n\n- Delete all a's:\n\n  ```bash\n  echo \"aabbccddee\" | tr -d a\n  ```\n  ```bash-out\n  bbccddee\n  ```\n\n- Remove consecutive duplicates a's:\n\n  ```bash\n  echo \"aabbccddee\" | tr -s a\n  ```\n  ```bash-out\n  abbccddee\n  ```\n:::\n\n::: {.callout-tip collapse=\"true\"}\n#### `tr` also works well with multiple values and replacements _(Click to expand)_\n\n- Replace multiple types of characters with one:\n\n```bash\necho \"123456789\" | tr 1-5 0    # Replace any of 1-5 with 0\n```\n```bash-out\n000006789\n```\n\n- One-to-one mapping of input and replacement!\n\n```bash\necho \"ACtGGcAaTT\" | tr actg ACTG\n```\n```bash-out\nACTGGCAATT\n```\n\n```bash\necho \"aabbccddee\" | tr a-c 1-3\n```\n```bash-out\n112233ddee\n```\n:::\n\n::: exercise\n#### {{< fa user-edit >}} Exercise: Redirecting `tr` output\n\nModify our command in which we changed the delimiter to a Tab to redirect the output\nto a new file, `Pacifici2013_data.tsv` (note the extension) in the `sandbox` dir\n(that's not where you are located yourself).\n\n<details><summary>Solution</summary>\n\n```bash\ncat Pacifici2013_data.csv | tr \";\" \"\\t\" > ../Pacifici2013_data.tsv\n```\n\n</details>\n:::\n\n<br>\n\n## Wrap-up & the Unix philosophy\n\n### The Unix philosophy\n\n> *This is the Unix philosophy: Write programs that do one thing and do it\n> well.* *Write programs to work together. Write programs to handle text\n> **streams**,* *because that is a universal interface.*<br> — Doug McIlory\n\n**Advantages of a modular approach:**\n\n-   Easier to spot errors\n-   Easy to swap out components, including in other languages\n-   Easier to learn (?)\n\n**Text \"streams\"?**\n\nRather than loading entire files into memory, process them one line at a time.\nVery useful with large files!\n\n```bash\n# This command would combine all files in the working dir ending in `.fa`\n# (i.e. FASTA files) into a single file -- even if that's multiple GBs,\n# this will not be a heavy lift at all!\ncat *.fa > combined.fa\n```\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}